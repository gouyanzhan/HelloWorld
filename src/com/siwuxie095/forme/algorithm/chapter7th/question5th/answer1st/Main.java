package com.siwuxie095.forme.algorithm.chapter7th.question5th.answer1st;

/**
 * 在其他数都出现偶数次的数组中找到出现奇数次的数
 *
 * 题目：
 * 给定一个整型数组 arr，其中只有一个数出现了奇数次，其他的数都出现了偶数次，打印这个数。
 *
 * 进阶：
 * 有两个数出现了奇数次，其他的数都出现了偶数次，打印这两个数。
 *
 * 要求：
 * 时间复杂度为 O(N)，额外空间复杂度为 O(1)。
 *
 * 解答：
 * 整数 n 与 0 异或的结果是 n，整数 n 与整数 n 异或的结果是 0。所以，先申请一个整型变量，
 * 记为 eO。在遍历数组的过程中，把 eO 和每个数异或（eO = eO^当前数），最后 eO 的值就是出
 * 现了奇数次的那个数。这是什么原因呢？因为异或满足交换律和结合律。为了方便说明，假设 A、B、
 * C 这三个数出现了偶数次，D 这个数出现了奇数次，并且出现的顺序为：C、B、D、A、A、B、C。因
 * 为异或运算满足交换律和结合律，所以任意调整异或出的 eO 结果是相同的：A、A、B、B、C、C、D。
 * 而按照这个顺序的异或最终结果就是 D。也就是说，先异或还是后异或某一个数，对最终的结果是没
 * 有任何影响的，最终结果等同于连续异或同一个出现偶数次的数之后，再连续异或下一个出现偶数次
 * 的数，等到所有出现偶数次的数异或完，异或的结果肯定是 0，最后再去异或出现奇数次的数，最终
 * 结果自然是出现奇数次的数。所以对任何排列的数组，只要这个数组有一个数出现了奇数次，另外的
 * 数出现了偶数次，最终异或结果都是出现了奇数次的数。具体代码请参看 printOddTimesNum1()
 * 方法。
 *
 * 如果只有 a 和 b 出现了奇数次，那么最后的异或结果 eO 就是 a^b。所以，如果数组中有两个出
 * 现奇数次的数，最终的 eO 一定不等于 0。那么肯定能在 32 位整数 eO 上找到一个不等于 0 的
 * bit 位，假设第 k 位不等于 0。eO 在第 k 位不等于 0，说明 a 和 b 的第 k 位肯定一个是 1
 * 另一个是 0。接下来再设置一个变量记为 eOHasOne，然后再遍历一次数组。在这次遍历时，eOHasOne
 * 只与第 k 位上是 1 的整数异或，其他的数忽略。那么在第二次遍历结束后，eOHasOne 就是 a 或
 * b 中的一个，而 eO^eOHasOne 就是另外一个出现奇数次的数。具体代码请参看 printOddTimesNum2()
 * 方法。
 *
 * @author Jiajing Li
 * @date 2019-05-19 14:10:14
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {1, 1, 2, 2, 3, 3, 4, 4, 5};
        Num.printOddTimesNum1(arr);
        arr = new int[]{1, 1, 2, 2, 3, 3, 4, 4, 5, 6};
        Num.printOddTimesNum2(arr);
    }

}
