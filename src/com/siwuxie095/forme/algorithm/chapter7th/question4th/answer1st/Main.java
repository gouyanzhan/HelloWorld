package com.siwuxie095.forme.algorithm.chapter7th.question4th.answer1st;

/**
 * 整数的二进制表达中有多少个 1
 *
 * 题目：
 * 给定一个 32 位整数 n，可为 0，可为正，也可为负，返回该整数二进制表达中 1 的个数。
 *
 * 解答：
 * 法一：最简单的解法。整数 n 每次进行无符号右移一位，检查最右边的 bit 是否为 1 来
 * 进行统计。具体代码请参看 count1() 方法。法一在最复杂的情况下要经过 32 次循环。
 *
 * 法二：是一个循环次数只与 1 的个数有关的解法。具体代码请参看 count2() 方法。每次
 * 进行 n &= (n-1) 操作，接下来在 while 循环中就可以忽略 bit 位上为 0 的部分。
 * 例如，n = 01000100，n-1 = 01000011，n & (n-1) = 01000000，说明处理到
 * 01000100 之后，下一步还得处理，因为 01000000 != 0。n = 01000000，n-1 =
 * 00111111，n & (n-1) = 00000000，说明处理到 01000000 之后，下一步就不用处理，
 * 因为接下来没有 1。所以，n &= (n-1) 操作的实质是抹掉最右边的 1。
 *
 * 法三：和法二的复杂度一样。具体代码请参看 count3() 方法。每次进行 n-=n&(~n+1)
 * 操作时，这也是移除最右侧的 1 的过程。等号右边 n&(~n+1) 的含义是得到 n 中最右侧
 * 的 1，这个操作在位运算的题目中经常出现。例如，n=01000100，n&(~n+1)=00000100，
 * n-(n&(~n+1))=01000000。n=01000000，n&(~n+1)=01000000，n-(n&(~n+1))=
 * 00000000。接下来不用处理了，因为没有 1。
 *
 * 法四：这是一种看上去很 "超自然" 的方法，叫做平行算法，具体代码请参看 count4()
 * 方法。整个过程类似并归的过程，组与组之间的数量合并成一个大组，进行下一步的并归。
 *
 * 除此之外，还有很多极为逆天的算法可以解决这个问题，比如 MIT hackmem 算法等。但是
 * 对于面试来说，那些方法实在太偏、太难、太怪，这里不再详述。
 *
 * @author Jiajing Li
 * @date 2019-05-18 22:12:36
 */
public class Main {

    public static void main(String[] args) {
        System.out.println(Count.count1(10));
        System.out.println(Count.count2(10));
        System.out.println(Count.count3(10));
        System.out.println(Count.count4(10));
    }

}
