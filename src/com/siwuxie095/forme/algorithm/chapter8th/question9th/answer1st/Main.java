package com.siwuxie095.forme.algorithm.chapter8th.question9th.answer1st;

/**
 * 不重复打印排序数组中相加和为给定值的所有二元组和三元组
 *
 * 题目：
 * 给定排序数组 arr 和整数 k，不重复打印 arr 中所有相加和为 k 的不降序二元组。
 * 比如：arr = [-8, -4, -3, 0, 1, 2, 4, 5, 8, 9]，k = 10，打印结果为：
 * 1, 9
 * 2, 8
 *
 * 补充题目：
 * 给定排序数组 arr 和整数 k，不重复打印 arr 中所有相加和为 k 的不降序三元组。
 * 比如：arr = [-8, -4, -3, 0, 1, 2, 4, 5, 8, 9]，k = 10，打印结果为：
 * -4, 5, 9
 * -3, 4, 9
 * -3, 5, 8
 * 0, 1, 9
 * 0, 2, 8
 * 1, 4, 5
 *
 * 解答：
 * 利用排序后的数组的特点，打印二元组的过程可以用一个左指针和一个右指针不断向中间
 * 压缩的方式实现，具体过程为：
 * 1、设置变量 left = 0，right = arr.length - 1。
 * 2、比较 arr[left] + arr[right] 的值（sum）与 k 的大小：
 * （1）如果 sum 等于 k，打印 "arr[left], arr[right]"，则 left++，right--。
 * （2）如果 sum 大于 k，right--。
 * （3）如果 sum 小于 k，left++。
 * 3、如果 left < right，则一直重复步骤 2，否则过程结束。
 * 那么如何保证不重复打印相同的二元组呢？只需在打印时增加一个检查即可，检查 arr[left]
 * 是否与它前一个值 arr[left-1] 相等，如果相等就不打印。具体解释为：因为整体是从
 * 两头向中间压缩的过程，如果 arr[left] + arr[right] == k，又有 arr[left]
 * == arr[left-1]，那么之前一定打印过这个二元组，此时无须重复打印。比如 arr =
 *[1, 1, 1, 9]，k = 10。首先打印 arr[0] 和 arr[3] 的组合，接下来就不再重复打
 * 印 1 和 9 这个二元组。
 * 具体代码请参看 printUniquePair() 方法，时间复杂度为 O(N)。
 *
 * 三元组的问题类似于二元组的求解过程。
 * 比如：
 * （1）当三元组的第一个值为 -8 时，寻找 -8 后面的子数组中所有相加为 18 的不重复
 * 二元组。
 * （2）当三元组的第一个值为 -4 时，寻找 -4 后面的子数组中所有相加为 14 的不重复
 * 二元组。
 * （3）当三元组的第一个值为 -3 时，寻找 -3 后面的子数组中所有相加为 13 的不重复
 * 二元组。
 * 以此类推。
 * 如何不重复打印相同的三元组呢？首先要保证每次寻找过程开始前，选定的三元组中第一个
 * 值不重复，其次就是和原问题的打印检查一样，要保证不重复打印二元组。
 * 具体代码请参看 printUniqueTriad() 方法，时间复杂度为 O(N^2)。
 *
 * @author Jiajing Li
 * @date 2019-05-27 17:59:59
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {-8, -4, -3, 0, 1, 2, 4, 5, 8, 9};
        Print.printUniquePair(arr, 10);
        System.out.println();
        Print.printUniqueTriad(arr, 10);
    }

}
