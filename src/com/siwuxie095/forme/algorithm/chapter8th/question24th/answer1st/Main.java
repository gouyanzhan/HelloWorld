package com.siwuxie095.forme.algorithm.chapter8th.question24th.answer1st;

/**
 * 求最短通路值
 *
 * 题目：
 * 用一个整型矩阵 matrix 表示一个网络，1 代表有路，0 代表无路，每一个位置只要不越界，都有
 * 上下左右 4 个方向，求从最左上角到最右下角到最短通路值。
 * 比如，matrix 为：
 * 1    0   1   1   1
 * 1    0   1   0   1
 * 1    1   1   0   1
 * 0    0   0   0   1
 * 通路只有一条，有 12 个 1 构成，所以返回 12。
 *
 * 解答：
 * 使用宽度优先遍历即可，如果矩阵大小为 N*M，这里提供的方法的时间复杂度为 O(N*M)，具体过程
 * 如下：
 * 1、开始时生成 map 矩阵，map[i][j] 的含义是从 (0, 0) 位置走到 (i, j) 位置最短的路径值。
 * 然后将左上角位置 (0, 0) 的行坐标和列坐标放入行队列 rQ 和列队列 cQ。
 * 2、不断从队列弹出一个位置 (r, c)，然后看这个位置的上下左右四个位置哪些在 matrix 上的值
 * 是 1，这些都是能走的位置。
 * 3、将那些能走的位置设置好各自在 map 中的值，即 map[r][c] + 1。同时将这些位置加入到 rQ
 * 和 cQ 中，用队列完成宽度优先遍历。
 * 4、在步骤 3 中，如果一个位置之前走过，就不要重复走，这个逻辑可以根据一个位置在 map 中的
 * 值来确定，比如 map[i][j] != 0，就可以知道这个位置之前已经走过。
 * 5、一直重复步骤 2 ～ 步骤 4。直到遇到右下角位置，说明已经找到终点，返回终点在 map 中的
 * 值即可，如果 rQ 和 cQ 已经为空都没有遇到终点位置，说明不存在这样一条路径，返回 0。
 *
 * 每个位置最多走一遍，所以时间复杂度为 O(N*M)、额外空间复杂度为 O(N*M)。
 *
 * @author Jiajing Li
 * @date 2019-06-11 22:08:03
 */
public class Main {

    public static void main(String[] args) {
        int[][] matrix = {
                {1, 0, 1, 1, 1},
                {1, 0, 1, 0, 1},
                {1, 1, 1, 0, 1},
                {0, 0, 0, 0, 1}
        };
        System.out.println(Value.minPathValue(matrix));
    }

}
