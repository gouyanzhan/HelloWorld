package com.siwuxie095.forme.algorithm.chapter8th.question4th;

/**
 * 找到无序数组中最小的 k 个数
 *
 * 题目：
 * 给定一个无序的整型数组 arr，找到其中最小的 k 个数。
 *
 * 要求：
 * 如果数组 arr 的长度为 N，排序之后自然可以得到最小的 k 个数，此时时间复杂度与排序的时间
 * 复杂度相同，均为 O(N*logN)。本题要求实现时间复杂度为 O(N*logk) 和 O(N) 的方法。
 *
 * 解答：
 * 依靠把 arr 进行排序的方法太简单，时间复杂度也不好，这里不再详述。
 * O(N*logk) 的方法。说起来也非常简单，就是一直维护一个有 k 个数的大根堆，这个堆代表目前
 * 选出的 k 个最小的数，在堆里的 k 个元素中堆顶的元素是最小的 k 个数里最大的那个。
 * 接下来遍历整个数组，遍历的过程中看当前数是否比堆顶元素小。如果是，就把堆顶元素替换称当前
 * 的数，然后从堆顶的位置调整整个堆，让替换操作后堆的最大元素继续处在堆顶的位置；如果不是，
 * 则不进行任何操作，继续遍历下一个数；在遍历完成后，堆中的 k 个数就是所有数组中最小的 k
 * 个数。
 * 具体代码请参看 getMinKNumsByHeap() 方法，其中 heapInsert() 和 heapify() 方法
 * 分别为堆排序中的建堆和调整堆的实现。
 *
 *
 * O(N) 的解法。需要用到一个经典的算法 -- BFPRT 算法，该算法于 1973 年由 Blum、Floyd、
 * Rivest、Tarjan 联合发明，其中蕴含的深刻思想改变了世界。BFPRT 算法解决了这样一个问题，
 * 在时间复杂度 O(N) 内，从无序的数组中找到第 k 小的数，就是再遍历一次数组的工作量而已，所
 * 以关键问题就变成了如何理解并实现 BFPRT 算法。
 * BFPRT 算法是如何找到第 k 小的数？以下是 BFPRT 算法的过程，假设 BFPRT 算法的函数是
 * int select(int[] arr, k)，该函数的功能为在 arr 中找到第 k 小的数，然后返回该数。
 *
 * select(arr, k) 的过程如下：
 * 1、将 arr 中的 n 个元素划分成 n/5 组，每组 5 个元素，如果最后的组不够 5 个元素，那么
 * 最后剩下的元素为 1 组（n%5 个元素）。
 * 2、对每个组进行插入排序，只针对每个组最多 5 个元素之间的组内排序，组与组之间并不排序。排
 * 序后找到每个组的中位数，如果组的元素个数为偶数，这里规定找到下中位数。
 * 3、步骤 2 中一共会找到 n/5 个中位数，让这些中位数组成一个新的数组，记为 mArr。递归调用
 * select(mArr, mArr.length/2)，意义是找到 mArr 这个数组中的中位数，即 mArr 中的第
 * mArr.length/2 小的数。
 * 4、假设步骤 3 中递归调用 select(mArr, mArr.length/2) 后，返回的数为 x。根据这个
 * x 划分整个 arr 数组（partition 过程），划分的过程为：在 arr 中，比 x 小的数都在 x
 * 左边，大于 x 的数都在 x 的右边，x 在中间。假设划分完成后，x 在 arr 中的位置记为 i。
 * 5、如果 i == k，说明 x 为整个数组中第 k 小的数，直接返回。
 * （1）如果 i < k，说明 x 处在第 k 小的数的左边，应该在 x 的右边寻找第 k 小的数，所以
 * 递归调用 select() 函数，在左半区寻找第 k 小的数。
 * （2）如果 i > k，说明 x 处在第 k 小的数的右边，应该在 x 的左边寻找第 k 小的数，所以
 * 递归调用 select() 函数，在右半区寻找第 i-k 小的数。
 *
 * BFPRT 算法为什么在时间复杂度上可以做到稳定的 O(N) 呢？以下是 BFPRT 的时间复杂度分析，
 * 假设 BFPRT 算法处理大小为 N 的数组时，时间复杂度为 T(N)。
 * 1、如上过程中，除了步骤 3 和步骤 5 要递归调用 select() 函数之外，其他所有的处理过程
 * 都可以在 O(N) 的时间内完成。
 * 2、步骤 3 中有递归调用 select() 的过程，且递归处理的数组大小最大为 n/5，即 T(N/5)。
 * 3、步骤 5 也递归调用了 select()，那么递归处理的数组大小最大为多少呢？具体的说，这里
 * 关心的是由 x 划分出的左半区最大有多大和由 x 划分出的左半区最大有多大。以下是整个右半区
 * 域的大小计算过程（左半区域的计算过程也类似），这也是整个 BFPRT 算法的精髓。
 * （1）因为 x 是 5 个数一组的中位数组成的数组 mArr 中的中位数，所以在 mArr 中（mArr
 * 的大小为 N/5），有一半的数(N/10 个)都比 x 要小。
 * （2）所有在 mArr 中比 x 小的所有数，在各自的组中又肯定比 2 个数要大，因为在 mArr 中
 * 的每一个数都是各自组中的中位数。
 * （3）所以至少有 (N/10)*3 个数比 x 要小，这里必须减去两个特殊的组，一个是 x 自己所在
 * 的组，一个是可能元素数量不足 5 个的组，所以至少有 (N/10 - 2)*3 的数比 x 要小。
 * （4）既然至少有 (N/10 - 2)*3 的数比 x 要小，那么至多有 N - (N/10 - 2)*3 的数比
 * x 要大，也就是 7N/10 + 6 个数比 x 要大，即右半区最大的量。
 * （5）左半区可以用类似的分析过程求出依然是至多有 7N/10 + 6 个数比 x 要小。
 * 所以整个步骤 5 的复杂度为 T(7N/10 + 6)。
 *
 * 综上所述，T(N) = O(N) + T(N/5) + T(7N/10 + 6)，可以在数学上证明 T(N) 的复杂度
 * 就是 O(N)，详细证明过程请参看相关图书（如：《算法导论》中 9.3 节的内容），这里不再详述。
 * 为什么要如此费力地处理 arr 数组呢？要 5 个数分一组，又要求中位数中的中位数，还要划分，
 * 好麻烦。这是因为以中位数的中位数 x 划分的数组可以在步骤 5 的递归时，确保淘汰一定的数据量，
 * 起码淘汰掉 3N/10 -6 的数据量。
 * 不得不说的是，关于选择划分元素的问题，很多实现都是随便找一个数进行数组的划分，也就是类似
 * 随机快速排序的划分方式，这种划分方式无法达到时间复杂度为 O(N) 的原因是不能确定淘汰的数据
 * 量，而 BFPRT 算法在划分时，使用的是中位数的中位数进行划分，从而确定了淘汰的数据量，最后
 * 成功地让时间复杂度收敛到 O(N) 的程度。
 *
 * 这里实现的 BFPRT 算法做了更好的改进，主要改进的地方是当中位数的中位数 x 在 arr 中大量
 * 出现时，那么在划分之后到底返回什么位置上的 x 呢？这里返回在通过 x 划分 arr 后，等于 x
 * 的整个位置区间。比如，pivotRange = [a, b] 表示 arr[a..b] 上都是 x，并以此区间去命
 * 中第 k 小的数，如果在 [a, b] 上，就是命中，如果没在 [a, b] 上，表示没命中。这样既可以
 * 尽量少地进行递归过程，又可以增加淘汰的数据量，使得步骤 5 的递归过程变得数据量更少。
 * 具体代码请参看 getMinKNumsByBFPRT() 方法。
 *
 * @author Jiajing Li
 * @date 2019-05-22 23:02:49
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {1, 1, 2, 3, 4, 5, 10, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1};
        int k = 8;

        int[] res = Num.getMinNumsByHeap(arr, k);
        for (int val : res) {
            System.out.print(val + " ");
        }

        System.out.println();
        res = Num.getMinKNumsByBFPRT(arr, k);
        for (int val : res) {
            System.out.print(val + " ");
        }
    }

}
