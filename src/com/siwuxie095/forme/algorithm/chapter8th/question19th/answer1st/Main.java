package com.siwuxie095.forme.algorithm.chapter8th.question19th.answer1st;

/**
 * 数组中子数组的最大累乘积
 *
 * 题目：
 * 给定一个 double 类型的数组 arr，其中的元素可正、可负、可 0，返回子数组累乘的最大乘积。例如，
 * arr = [-2.5, 4, 0, 3, 0.5, 8, -1]，子数组 [3, 0.5, 8] 累乘可以获得最大的乘积 12，所
 * 以返回 12。
 *
 * 解答：
 * 本题可以做到时间复杂度为 O(N)、额外空间复杂度为 O(1)。所有的子数组都会以某一个位置结束，所以，
 * 如果求出以每一个位置结尾的子数组最大的累乘积，在这么多最大累乘积中最大的那个就是最终的结果。也
 * 就是说，结果 = Max{以 arr[0] 结尾的所有子数组的最大累乘积，以 arr[1] 结尾的所有子数组的最大
 * 累乘积 ... 以 arr[arr.length-1] 结尾的所有子数组的最大累乘积}。
 * 如何快速求出所有以 i 位置结尾（arr[i]）的子数组的最大乘积呢？假设以 arr[i-1] 结尾的最小累乘
 * 积为 min，以 arr[i-1] 结尾的最大累乘积为 max，那么，以 arr[i] 结尾的最大累乘积只有以下三种
 * 可能：
 * （1）可能是 max*arr[i]。max 既然表示以 arr[i-1] 结尾的最大累乘积，那么当然有可能以 arr[i]
 * 结尾的最大累乘积是 max*arr[i]。例如，[3, 4, 5] 在算到 5 的时候。
 * （2）可能是 min*arr[i]。min 既然表示以 arr[i-1] 结尾的最小累乘积，当然有可能 min 是负数，
 * 而如果 arr[i] 也是负数，两个负数相乘的结果也可能很大。例如，[-2, 3, -4] 在算到 -4 的时候。
 * （3）可能仅是 arr[i] 的值。以 arr[i] 结尾的最大累乘积并不一定非要包含 arr[i] 之前的数。例如，
 * [0.1, 0,1, 100] 在算到 100 的时候。
 * 这三种可能的值中最大的那个就作为以 i 位置结尾的最大累乘积，最小的作为最小累乘积，然后继续计算以
 * i+1 位置结尾的时候，如此重复，直到计算结束。
 *
 * @author Jiajing Li
 * @date 2019-06-09 21:16:48
 */
public class Main {

    public static void main(String[] args) {
        double[] arr = {-2.5, 4, 0, 3, 0.5, 8, -1};
        System.out.println(Product.maxProduct(arr));
    }

}
