package com.siwuxie095.forme.algorithm.chapter8th.question17th.answer1st;

/**
 * 子矩阵的最大累加和问题
 *
 * 题目：
 * 给定一个矩阵 matrix，其中的值有正、有负、有 0，返回子矩阵的最大累加和。
 *
 * 比如，矩阵 matrix 为：
 * -90  48  78
 * 64   -40 64
 * -81  -7  66
 * 其中，最大累加和的子矩阵为：
 * 48   78
 * -40  64
 * -7   66
 * 所以返回累加和为 209。
 *
 * 比如，矩阵 matrix 为：
 * -1   -1  -1
 * -1   2   2
 * -1   -1  -1
 * 其中，最大累加和的子矩阵为：
 * 2    2
 * 所以返回累加和 4。
 *
 * 解答：
 * 可以参见 "子数组的最大累加和问题" 这个问题，因为本题的最优解深度利用了该题的解法。首先
 * 来看这样一个例子，假设一个 2 行 4 列的矩阵如下：
 * -2   3   -5  7
 * 1    4   -1  -3
 * 如何求必须含有 2 行元素的子矩阵中的最大累加和？可以把两列的元素累加，然后得到累加数组
 * [-1, 7, -6, 4]，接下来求这个累加数组的最大累加和，结果是 7。也就是说，必须含有 2 行
 * 元素的子矩阵中的最大和为 7，且这个子矩阵是：
 * 3
 * 4
 * 也就是说，如果一个矩阵一共有 k 行且限定必须含有 k 行元素的情况下，只要把矩阵中的每一列
 * 的 k 个元素累加生成一个累加数组，然后求出这个数组的最大累加和，这个最大累加和就是必须含
 * 有 k 行元素的子矩阵中的最大累加和。
 * 请读者务必理解以上解释，下面看原问题如何求解。为了方便讲述，用题目的第一个例子来展示求解
 * 过程，首先考虑只有一行的矩阵 [-90, 48, 78]，因为只有一行，所以累加数组 arr 就是 [-90,
 * 48, 78]，这个数组的最大累加和为 126。
 * 接下来考虑含有两行的矩阵：
 * -90  48  78
 * 64   -40 64
 * 这个矩阵的累加数组就是在上一步的累加数组 [-90, 48, 78] 的基础上，依次在每个位置上加上
 * 矩阵最新一行 [64, -40, 64] 的结果，即 [-26, 8, 142]，这个数组的最大累加和为 150。
 * 接下来考虑含有三行的矩阵：
 * -90  48  78
 * 64   -40 64
 * -81  -7  66
 * 这个矩阵的累加数组就是在上一步累加数组 [-26, 8, 142] 的基础上，依次在每个位置上加上矩
 * 阵最新一行 [-81, -7, 66] 的结果，即 [-107, 1, 208]，这个数组的最大累加和为 209。
 * 此时，必须从矩阵的第一行元素开始，并往下的所有子矩阵以及查找完毕，接下来从矩阵的第二行开
 * 始，继续这样的过程，含有一行矩阵：
 * 64   -40 64
 * 因为只有一行，所以累加数组就是 [64, -40, 64]，这个数组的最大累加和为 88。
 * 接下来考虑含有两行的矩阵：
 * 64   -40 64
 * -81  -7  66
 * 这个矩阵的累加数组就是在上一步累加数组 [64, -40, 64] 的基础上，依次在每个位置上加上矩
 * 阵最新一行 [-81, -7, 66] 的结果，即 [-17, -47, 130]，这个数组的最大累加和为 130。
 * 此时，必须从矩阵的第二行元素开始，并往下的所有子矩阵已经查找完毕，接下来从矩阵的第三行开
 * 始，继续这样的过程，含有一行矩阵：
 * -81  -7  66
 * 因为只有一行，所以累加数组就是 [-81, -7, 66]，这个数组的最大累加和为 66。
 * 全部过程结束，所有的子矩阵都已经考虑到了，结果为以上所有最大累加和中最大的 209。
 * 整个过程最关键的地方有两处：
 * （1）用求累加数组的最大累加和的方式得到每一步的最大子矩阵的累加和。
 * （2）每一步的累加数组可以利用前一步求出的累加数组很方便的更新得到。
 * 如果矩阵大小为 N*N 的，以上全部过程的时间复杂度为 O(N^3)。
 *
 * @author Jiajing Li
 * @date 2019-06-09 18:40:08
 */
public class Main {

    public static void main(String[] args) {
        int[][] matrix = {
                {-90, 48, 78},
                {64, -40, 64},
                {-81, -7, 66}
        };
        System.out.println(Sum.maxSum(matrix));
    }

}
