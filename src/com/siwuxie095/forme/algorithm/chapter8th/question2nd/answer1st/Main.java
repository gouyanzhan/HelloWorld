package com.siwuxie095.forme.algorithm.chapter8th.question2nd.answer1st;

/**
 * 将正方形矩阵顺时针转动 90 度
 *
 * 题目：
 * 给定一个 N*N 的矩阵 matrix，把这个矩阵调整成顺时针转动 90 度后的形式。
 *
 * 比如：
 * 1    2   3   4
 * 5    6   7   8
 * 9    10  11  12
 * 13   14  15  16
 * 顺时针转动 90 度后为：
 * 13   9   5   1
 * 14   10  6   2
 * 15   11  7   3
 * 16   12  8   4
 *
 * 要求：额外空间复杂度为 O(1)。
 *
 * 解答：
 * 这里仍使用分圈处理的方式，在矩阵中用左上角的坐标 (tR, tC) 和右下角的坐标 (dR, dC) 就可以
 * 表示一个子矩阵。比如，题目中的矩阵，当 (tR, tC) = (0, 0)，(dR, dC) = (3, 3) 时，表示的
 * 子矩阵就是整个矩阵，那么这个矩阵的最外层部分如下：
 * 1    2   3   4
 * 5            8
 * 9            12
 * 13   14  15  16
 * 在这个外圈中，1、4、16、13 为一组，然后让 1 占据 4 的位置，4 占据 16 的位置，16 占据 13
 * 的位置，13 占据 1 的位置，一组就调整完了。然后 2、8、15、9 为一组，继续占据调整的过程，最
 * 后 3、12、14、5 为一组，继续占据调整的过程。然后 (tR, tC) = (0, 0)，(dR, dC) = (3, 3)
 * 的子矩阵外层就调整完毕。接下来，令 tR 和 tC 加 1，即 (tR, tC) = (1, 1)，令 dR 和 dC 减
 * 1，即 (dR, dC) = (2, 2)，此时表示的子矩阵如下：
 * 6    7
 * 10   11
 * 这个外层只有一组，就是 6、7、10、11，占据调整之后即可。所以，如果子矩阵的大小是 M*M，一共
 * 就有 M-1 组，分别进行占据调整即可。
 *
 * @author Jiajing Li
 * @date 2019-05-20 22:31:39
 */
public class Main {

    public static void main(String[] args) {
        int[][] matrix = {
                {1, 2, 3, 4},
                {5, 6, 7, 8},
                {9, 10, 11, 12},
                {13, 14, 15, 16}
        };
        Rotate.rotate(matrix);
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                System.out.printf("%7s", matrix[i][j]);
            }
            System.out.println();
        }
    }

}
