package com.siwuxie095.forme.algorithm.chapter8th.question26th.answer1st;

/**
 * 数组排序之后相邻数的最大差值
 *
 * 题目：
 * 给定一个整型数组 arr，返回排序后的相邻两数的最大差值。
 *
 * 比如：
 * arr=[9, 3, 1, 10]，如果排序，结果为 [1, 3, 9, 10]，9 和 3 的差为最大差值，故返回 6。
 * arr=[5, 5, 5, 5]，返回 0。
 *
 * 要求：
 * 如果 arr 的长度为 N，请做到时间复杂度为 O(N)。
 *
 * 解答：
 * 本题如果用排序法实现，其时间复杂度为 O(N*logN)，而如果利用桶排序的思想（不是直接进行桶排序），可以做到
 * 时间复杂度为 O(N)，额外空间复杂度为 O(N)。遍历 arr 找到最小值和最大值，分别记为 min 和 max。如果 arr
 * 的长度为 N，那么准备 N+1 个桶，把 max 单独放在第 N+1 个桶里。arr 中在 [min, max) 范围上的数放在 1
 * ～N 号桶里，对于 1～N 号桶中的每一个桶来说，负责的区间大小为 (max-min)/N。比如长度为 10 的数组 arr
 * 中，最小值为 10，最大值 110。那么就准备 11 个桶，arr 中等于 110 的数全部放在第 11 号桶里。区间 [10,
 * 20) 的数全部放在 1 号桶里，区间 [20, 30) 的数全部放在 2 号桶里...，区间 [100, 110) 的数全部放在 10
 * 号桶里。那么如果一个数为 num，它应该分配进 (num-min)*len/(max-min) 号桶里。
 * arr 一共有 N 个数，min 一定会放进 1 号桶里，max 一定会放进最后的桶里，所以，如果把所有的数放入 N+1 个
 * 桶中，必然有桶是空的。如果 arr 经过排序，相邻的数有可能此时在同一个桶中，也可能在不同的桶中。在同一个桶中
 * 的任何两个数的差值都不会大于区间值，而在空桶左右两边不空的桶里，相邻数的差值肯定大于区间值。所以产生最大差
 * 值的两个相邻数肯定来自不同的桶。所以只要计算桶之间数的间距就可以，也就是只用记录每个桶的最大值和最小值，最
 * 大差值只可能来自某个非空桶的最小值减去前一个非空桶的最大值。
 *
 * @author Jiajing Li
 * @date 2019-06-11 23:10:36
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {9, 3, 1, 10};
        System.out.println(Gap.maxGap(arr));
    }

}
