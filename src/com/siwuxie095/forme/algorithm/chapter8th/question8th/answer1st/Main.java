package com.siwuxie095.forme.algorithm.chapter8th.question8th.answer1st;

/**
 * 最长可整合子数组的长度
 *
 * 题目：
 * 先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数相差的绝对值都为 1，则该数组为可整合数组。
 * 例如，[5, 3, 4, 6, 2] 排序之后为 [2, 3, 4, 5, 6]，符合每相邻两个数差的绝对值都为 1，所以这个
 * 数组为可整合数组。
 * 给定一个数组 arr，请返回其中最大可整合子数组的长度。例如，[5, 5, 3, 2, 6, 4, 3] 的最大可整合子
 * 数组为 [5, 3, 2, 6, 4]，所以返回 5。
 *
 * 解答：
 * 时间复杂度高但容易理解的解法。对 arr 中的每一个子数组 arr[i..j]（0 <= i <= j <= N-1），都验证
 * 一下是否符合可整合数组的定义，也就是把 arr[i..j] 排序一下，看是否依次递增且每次递增 1，然后在所有符
 * 合可整合数组定义的子数组中，记录最大的那个长度，返回即可。
 * 需要注意的是，在考查每一个 arr[i..j] 是否符合可整合数组定义的时候，都得把 arr[i..j] 单独复制成一
 * 个新的数组，然后把这个新的数组排序、验证，而不能直接改变 arr 中元素的顺序。
 * 所以大体过程如下：
 * 1、依次考查每一个子数组 arr[i..j]，一共有 O(N^2) 个。
 * 2、对每一个子数组 arr[i..j]，复制成一个新的数组，记为 newArr，把 newArr 排序，然后验证是否符合可
 * 整合数组的定义，这一步代价为 O(N*logN)。
 * 3、步骤 2 中符合条件的、最大的那个子数组的长度就是结果。
 * 具体代码请参看 getLIL1() 方法，时间复杂度为 O(N^2) * O(N*logN)  ->  O(N^3 * logN)。
 *
 * 第一种方法严格按照题目的意思来验证每一个子数组是否是可整合数组，但是验证可整合数组真的需要如此麻烦吗？
 * 有没有更好的方法来加速验证过程？这也是第二种方法的核心。可以这样判断一个数组是否是可整合数组，一个数组
 * 中如果没有重复元素，并且如果最大值减去最小值，再加 1 的结果等于元素个数（max - min + 1 == 元素个数），
 * 那么这个数组就是可整合数组。比如，[3, 2, 5, 6, 4]，max - min + 1 == 5 == 元素个数，所以这个数
 * 组是可整合数组。
 * 这样，验证每一个子数组是否是可整合数组的时间复杂度可以从第一种方法的 O(N*logN) 加速至 O(1)，整个过程
 * 的时间复杂度就可加速到 O(N^2)。具体代码请参看 getLIL2() 方法。
 *
 * @author Jiajing Li
 * @date 2019-05-27 17:16:15
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {5, 5, 3, 2, 6, 4, 3};
        System.out.println(Length.getLIL1(arr));
        System.out.println(Length.getLIL2(arr));
    }

}
