package com.siwuxie095.forme.algorithm.chapter8th.question12th.answer1st;

/**
 * 未排序数组中累加和小于或等于给定值的最长子数组长度
 *
 * 题目：
 * 给定一个无序数组 arr，其中元素可正、可负、可 0，给定一个整数 k。求 arr 所有的子数组中累加和
 * 小于或等于 k 的最长子数组长度。
 * 比如：arr = [3,-2,-4,0,6]，k=-2，相加和小于或等于 -2 的最长子数组为 [3,-2,-4,0]，所以结
 * 果返回 4。
 *
 * 解答：
 * 这里提供的方法可以做到时间复杂度为 O(N*logN)，额外空间复杂度为 O(N)。
 * 依次求以数组的每个位置结尾的、累加和小于或等于 k 的最长子数组长度，其中最长的那个子数组的长度就
 * 是结果。为了便于理解，举一个比较具体的例子。
 * 假设处理到位置 30，从位置 0 到位置 30 的累加和为 100（sum[0..30] = 100），现在想求以位置 30
 * 结尾的、累加和小于或等于 10 的最长子数组长度。再假设从位置 0 开始累加到位置 10 的时候，累加和第
 * 一次大于或等于 90（sum[0..10] >= 90），那么可以知道以位置 30 结尾的相加和小于或等于 10 的最长
 * 就是 arr[11..30]。也就是说，如果从 0 位置到 j 位置的累加和为 sum[0..j]，此时想求以 j 位置结
 * 尾的相加和小于或等于 k 的最长子数组长度。那么只要知道大于或等于 sum[0..j]-k 这个值的累加和最早
 * 出现在 j 之前的什么位置就可以，假设那个位置是 i 位置，那么 arr[i+1..j] 就是 j 位置结尾的相加和
 * 小于或等于 k 的最长子数组。
 * 为了很方便地找到大于或等于某一个值的累加和最早出现的位置，可以按照如下方法生成辅助数组 helpArr。
 * 1、首先生成 arr 每个位置从左到右的累加和数组 sumArr，以 [1,2,-1,5,-2] 为例，生成的 sumArr
 * =[0,1,3,2,7,5]。注意，sumArr 中的第一个数为 0，表示当没有任何一个数时的累加和为 0。
 * 2、生成 sumArr 的左侧最大值数组 helpArr，sumArr = {0,1,3,2,7,5} -> helpArr = {0,1,3,3,
 * 7,7}。为什么原来的 sumArr 数组中的 2 和 5 变成 3 和 7 呢？因为这里只关心大于或等于某一个值的
 * 累加和最早出现的位置，而累加和 3 出现在 2 之前，并且大于或等于 3 必然大于 2。所以，当然要保留一
 * 个更大的、出现更早的累加和。
 * 3、helpArr 是 sumArr 每个位置上的左侧最大值数组，那么它当然是有序的。在这样一个有序的数组中，就
 * 可以二分查找大于或等于某一个值的累加和最早出现的位置。例如，在 [0,1,3,3,7,7] 中查找大于或等于 4
 * 这个值的位置，就是第一个 7 的位置。
 *
 * 以原题中给的例子来说明整个计算过程。arr = [3,-2,-4,0,6]，k = -2。
 * 1、arr = [3,-2,-4,0,6]，求得 arr 的累加数组 sumArr = [0,3,1,-3,-3,3]，进一步求得 sumArr
 * 的左侧最大值数组 [0,3,3,3,3,3]。
 * 2、j = 0 时，sum[0..0] = 3，所以在 helpArr 中二分查找大于或等于 3-k=3-(-2)=5 这个值第一次
 * 出现的位置，结果是没有。所以，可知以位置 0 结尾的所有子数组累加后没有小于或等于 k（即 -2）的。
 * 3、j = 1 时，sum[0..1] = 1，所以在 helpArr 中二分查找大于或等于 1-k=1-(-2)=3 这个值第一次
 * 出现的位置，在 helpArr 中的位置是 1，对应的 arr 中的位置是 0。所以，arr[1..1] 是满足条件的最
 * 长数组。
 * 4、j = 2 时，sum[0..2] = -3，所以在 helpArr 中二分查找大于或等于 -3-k=-3-(-2)=-1 这个值第
 * 一次出现的位置，在 helpArr 中的位置是 0，对应的 arr 中的位置是 -1，表示一个数都不累加的情况，所
 * 以 arr[0..2] 是满足条件的最长数组。
 * 5、j = 3 时，sum[0..3] = -3，所以在 helpArr 中二分查找大于或等于 -3-k=-3-(-2)=-1 这个值第
 * 一次出现的位置，在 helpArr 中的位置是 0，对应的 arr 中的位置是 -1，表示一个数都不累加的情况，所
 * 以 arr[0..3] 是满足条件的最长数组。
 * 6、j = 4 时，sum[0..4] = 3，所以在 helpArr 中二分查找大于或等于 3-k=3-(-2)=5 这个值第一次
 * 出现的位置，结果是没有。所以，可知以位置 4 结尾的所有子数组累加后没有小于或等于 k（即 -2）的。
 *
 * @author Jiajing Li
 * @date 2019-06-02 13:36:44
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {3, -2, -4, 0, 6};
        System.out.println(Length.maxLength(arr, -2));
    }

}
