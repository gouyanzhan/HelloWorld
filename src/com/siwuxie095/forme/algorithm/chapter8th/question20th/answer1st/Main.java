package com.siwuxie095.forme.algorithm.chapter8th.question20th.answer1st;

/**
 * 打印 N 个数组整体最大的 Top K
 *
 * 题目：
 * 有 N 个长度不一的数组，所有的数组都是有序的，请从小到大打印这 N 个数组整体最大的前 K 个数。
 * 比如，输入含有 N 行元素的二维数组可以代表 N 个一维数组。
 * 219, 405, 538, 845, 971
 * 148, 558
 * 52, 88, 348, 691
 * 再输入整数 k = 5，则打印：
 * Top 5: 971, 845, 691, 558, 538
 *
 * 要求：
 * 1、如果所有数组的元素个数小于 K，则从大到小打印所有的数。
 * 2、要求时间复杂度为 O(K*logN)。
 *
 * 解答：
 * 本题的解法是利用堆结构和堆排序的过程完成的，具体过程如下：
 * 1、构建一个大小为 N 的大根堆 heap，建堆的过程就是把每一个数组中的最后一个值，也就是该数组
 * 的最大值，依次加入到堆里，这个过程是建堆时的调整过程（heapInsert）。
 * 2、建好堆之后，此时 heap 堆顶的元素是所有数组的最大值中最大的那个，打印堆顶元素。
 * 3、假设堆顶元素来自 a 数组的 i 位置。那么接下来就把堆顶的前一个数（即 a[i-1]）放在 heap
 * 的头部，也就是用 a[i-1] 替换原本的堆顶，然后从堆的头部开始调整堆，使其重新变为大根堆（heapify
 * 过程）。
 * 4、这样每次都可以得到一个堆顶元素 max，在打印完成后都经历步骤 3 的调整过程。整体打印 k 次，
 * 就是从大到小全部的 Top K。
 * 5、在重复步骤 3 的过程中，如果 max 来自的那个数组（仍假设是 a 数组）已经没有元素。也就是说，
 * max 已经是 a[0]，再往左没有数了。那么就把 heap 中最后一个元素放在 heap 头部的位置，然后把
 * heap 的大小减 1（heapSize - 1），最后依然是从堆的头部开始调整堆，使其重新变为大根堆（堆大
 * 小减 1 之后的 heapify 过程）。
 * 6、直到打印了 k 个数，过程结束。
 *
 * 为了知道每一次 max 来自什么数组的什么位置，放在堆里的元素是 HeapNode 类。
 *
 * @author Jiajing Li
 * @date 2019-06-09 21:38:01
 */
public class Main {

    public static void main(String[] args) {
        int[][] matrix = {
                {219, 405, 538, 845, 971},
                {148, 558},
                {52, 88, 348, 691}
        };
        TopK.printTopK(matrix, 5);
    }

}
