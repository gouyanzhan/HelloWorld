package com.siwuxie095.forme.algorithm.chapter8th.question25th.answer1st;

/**
 * 数组中未出现的最小正整数
 *
 * 题目：
 * 给定一个无序整型数组 arr，找到数组中未出现的最小正整数。
 *
 * 比如：
 * arr = [-1, 2, 3, 4]，返回 1。
 * arr = [1, 2, 3, 4]，返回 5。
 *
 * 解答：
 * 原问题。如果 arr 长度为 N，本题的最优解可以做到时间复杂度为 O(N)，额外空间复杂度为 O(1)。
 * 具体过程如下：
 * 1、在遍历 arr 之前先生成两个变量。变量 l 表示遍历到目前为止，数组 arr 已经包含的正整数范
 * 围是 [1, l]，所以没有开始遍历之前令 l = 0，表示 arr 目前没有包含任何正整数。变量 r 表示
 * 遍历到目前为止，在后续出现最优状况的情况下，arr 可能包含的正整数范围是 [l, r]，所以没有开
 * 始遍历之前，令 r = N，因为还没有开始遍历，所以后续出现的最优状况是 arr 包含 1～N 所有的整
 * 数。r 同时表示 arr 当前的结束位置。
 * 2、从左到右遍历 arr，遍历到位置 l，位置 l 的数为 arr[l]。
 * 3、如果 arr[l] == l + 1。没有遍历 arr[l] 之前，arr 已经包含的正整数范围是 [1, l]，此
 * 时出现了 arr[l] == l + 1 的情况，所以 arr 包含的正整数范围可以扩到 [1, l+1]，即令 l++。
 * 然后重复步骤 2。
 * 4、如果 arr[l] <= 1。没有遍历 arr[l] 之前，arr 在后续最优的情况下可能包含的正整数范围是
 * [l, r]，已经包含的正整数范围是 [1, l]，所以需要 [l+1, r] 上的数。而此时出现了 arr[l] <
 * = 1，说明 [l+1, r] 范围上的数少了一个，所以 arr 在后续最优的情况下，可能包含的正整数范围
 * 缩小了，变为 [l, r-1]，此时把 arr 最后位置的数（arr[r-1]）放在位置 l 上，下一步检查这个
 * 数，然后令 r--。重复步骤 2。
 * 5、如果 arr[l] > r，与步骤 4 同理，把 arr 最后位置的数（arr[r-1]）放在位置 l 上，下一步
 * 检查这个数，然后令 r--，重复步骤 2。
 * 6、如果 arr[arr[l]-1] == arr[l]。如果步骤 4 和步骤 5 没中，说明 arr[l] 是在 [l+1, r]
 * 范围上的数，而且这个数应该放在 arr[l] - 1 位置上。可是此时发现 arr[l] - 1 位置上的数已经
 * 是 arr[l]，说明出现两个 arr[l]，既然在 [l+1, r] 上出现了重复值，那么 [l+1, r] 范围上的
 * 数又少了一个，所以步骤 4 和步骤 5 一样，把 arr 最后位置的数（arr[r-1]）放在位置 l 上，下
 * 一步检查这个数，然后令 r--，重复步骤 2。
 * 7、如果步骤 4、步骤 5 和步骤 6 都没中，说明发现了 [l+1, r] 范围上的数，并且此时并未发现重
 * 复。那么 arr[l] 应该放到 arr[l] - 1 位置上，所以把 l 位置上的数和 arr[l] - 1 位置上的数
 * 交换，下一步继续遍历 l 位置上的数，重复步骤 2。
 * 8、最终 l 位置和 r 位置会碰到一起（l == r），arr 已经包含的正整数范围是 [1, l]，返回 l+1
 * 即可。
 *
 * @author Jiajing Li
 * @date 2019-06-11 22:36:56
 */
public class Main {

    public static void main(String[] args) {
        int[] arr1 = {-1, 2, 3, 4};
        System.out.println(Number.missNum(arr1));
        int[] arr2 = {1, 2, 3, 4};
        System.out.println(Number.missNum(arr2));
    }

}
