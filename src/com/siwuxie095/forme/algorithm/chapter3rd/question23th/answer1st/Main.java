package com.siwuxie095.forme.algorithm.chapter3rd.question23th.answer1st;

import java.util.List;

/**
 * 统计和生成所有不同的二叉树
 *
 * 题目：
 * 给定一个整数 N，如果 N < 1，代表空树结构，否则代表中序遍历的结果为 {1,2,3 ... N}，
 * 请返回可能的二叉树结构有多少。
 *
 * 例如：N = -1 时，代表空树结构，返回 1；N = 2 时，满足中序遍历为 {1,2} 的二叉树结
 * 构只有两种，返回 2。
 *
 * 进阶：N 的含义不变，假设可能的二叉树结构有 M 种，请返回 M 个二叉树的头节点，每一棵
 * 二叉树代表一种可能的结构。
 *
 * 解答：
 * 如果中序遍历有序且无重复值，则二叉树必为搜索二叉树。假设 num(a) 代表 a 个节点的搜索
 * 二叉树有多少种可能，再假设序列为 {1,2,3 ... i ... N}，如果以 1 作为头节点， 1 不
 * 可能有左子树，故以 1 作为头节点有多少种可能的结构，完全取决于 1 的右子树有多少种可能
 * 结构，1 的右子树有 N-1 个节点，所以有 num(N-1) 种可能。
 * 如果以 i 作为头节点，i 的左子树有 i-1 个节点，所以可能的结构有 num(i-1) 种，右子树
 * 有 N-i 个节点，所以有 num(N-i) 种可能。故以 i 为头节点的可能结构有 num(i-1)*num(N-i)
 * 种。
 * 如果以 N 作为头节点，N 不可能有右子树，故以 N 作为头节点有多少种可能，完全取决于 N
 * 的左子树有多少种可能，N 的左子树有 N-1 个节点，所以有 num(N-1) 种。
 * 把从 1 到 N 分别作为头节点时，所有可能的结构加起来就是答案，可以利用动态规划来加速计
 * 算的过程，从而做到 O(N^2) 的时间复杂度。
 *
 * 进阶问题与原问题的过程其实是类似的。如果要生成中序遍历是 {a...b} 的所有结构，就从 a
 * 开始一直到 b，枚举每一个值作为头节点，把每次生成的二叉树结构的头节点都保存下来即可。假
 * 设其中一次是以 i 值为头节点的(a<=i<=b)，以 i 头节点的所有结构都按如下步骤生成：
 * 1、用 {a...i-1} 递归生成左子树的所有结构，假设所有结构的头节点保存在 listLeft 链表
 * 中。
 * 2、用 {a...i+1} 递归生成右子树的所有结构，假设所有结构的头节点保存在 listRight 链表
 * 中。
 * 3、在以 i 为头节点的前提下，listLeft 中每一种结构都可以与 listRight 中每一种结构构
 * 成单独的结构，且和其它任何结构都不同。为了保证所有的结构之间不互相交叉，所以对每一种结构
 * 都复制出新的树，并记录在总的链表 resList 中。
 *
 * @author Jiajing Li
 * @date 2019-03-31 14:22:33
 */
public class Main {

    public static void main(String[] args) {

        System.out.println(Generate.numTrees(3));

        System.out.println();

        List<Node> resList = Generate.generateTrees(3);
        for (Node res : resList) {
            System.out.println(res.value);
        }

    }

}
