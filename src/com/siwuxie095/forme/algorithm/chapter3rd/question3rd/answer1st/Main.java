package com.siwuxie095.forme.algorithm.chapter3rd.question3rd.answer1st;

/**
 * 如何较为直观地打印二叉树
 *
 * 题目：
 * 二叉树可以用常规的三种遍历结果来描述其结构，但是不够直观，尤其是二叉树中有重复值的时候，仅通过
 * 三种遍历的结果来构造二叉树的真实结构更是难上加难，有时则根本不可能。给定一棵二叉树的头节点 head，
 * 已知二叉树节点值的类型为 32 位整型，请实现一个打印二叉树的函数，可以直观地展示树的形状，也便于
 * 画出真实的结构。
 *
 * 解答：
 * 本题较为开放，不仅要设计出符合要求且不会产生歧义的打印方式，还要考虑实现难度，在面试时仅仅写出
 * 思路必然是不满足代码面试要求的。这里给出一种符合要求且代码量不大的实现（其实还能优化），具体过
 * 程如下：
 * 1、设计打印的样式。首先应该解决的就是用什么样的方式来无歧义地打印二叉树。
 *                1
 *            /      \
 *          2         3
 *        /         /  \
 *       4         5   6
 *         \
 *          7
 * 对上面这棵二叉树，这里设计的打印样式为：
 *                  v6v
 *
 *          v3v
 *
 *                  ^5^
 *
 * H1H
 *
 *
 *          ^2^
 *                          v7v
 *                  ^4^
 * 下面解释一下如何看打印的结果。首先，二叉树大概的样子是把打印结果顺时针旋转90度。怎么清晰的确定
 * 任何一个节点的父节点？
 * 1）如果一个节点的打印结果的前缀与后缀都有 H，说明这个节点是头节点，显然它并不存在父节点。
 * 2）如果一个节点的打印结果的前缀与后缀都有 v，表示父节点在该节点所在列的前一列，在该节点所在行的下
 * 方（下一行），并且是离该节点最近的节点。
 * 3）如果一个节点的打印结果的前缀与后缀都有 ^，表示父节点在该节点所在列的前一列，在该节点所在行的上
 * 方（上一行），并且是离该节点最近的节点。
 *
 * 2、一个需要重点考虑的问题 - 规定节点打印时占用的统一长度。即 必须规定一个节点在打印时到底占多长。
 * 试想，如果某些节点的值本身长度很短，而有些节点的值本身长度很长，在没有规定一个统一的长度的情况下，
 * 打印一个长短值交替的二叉树时必然会出现格式对不齐的问题，进而产生歧义。在 Java 中，整型值占用长度
 * 最长的值是 Integer.MIN_VALUE（-2147483648），占用的长度为 11，加上前缀和后缀之后占用长度为
 * 13。为了在打印之后更好的区分，再把前面加上两个空格，后面加上两个空格，总共占用长度为 17。也就是说
 * 长度为 17 的空间必然可以放下任何一个 32 位整数，同时样式还不错。
 * 所以，这里约定，打印每一个节点时，必须让每一个节点的占用长度为 17，如果不足，前后都用空格补齐。
 *
 * 3、确定了打印样式，规定了占用长度的标准后，再来解释具体的实现。打印的整体过程结合了二叉树先右子树、
 * 再根节点、最后左子树的递归遍历过程（右-根-左）。如果递归到一个节点，首先遍历它的右子树。右子树遍历
 * 完毕，回到这个节点，如果这个节点所在层为 1，那么先打印 1*17 个空格（不换行），然后开始制作该节点
 * 的打印内容，这个内容当然包括节点的值，以及确定的前后缀字符。如果该节点是其父节点的右孩子，前后缀为
 * v，如果是其父节点的左孩子，前后缀为 ^，如果是头节点，前后缀为 H。最后在前后分别贴上数量几乎一致的
 * 空格，占用长度为 17 的打印内容就制作完毕，打印它并换行。最后进行左子树的遍历。
 *
 * 扩展：
 * 有关功能设计的题目，其实最难的部分并不是设计，而是在设计的优良性和实现的复杂程度之间找到一个平衡性
 * 最好的设计方案。在满足功能要求的同时，也要保证在面试现场能完成大致的代码实现，同时对边界条件的梳理
 * 能力和代码逻辑的实现能力也是一大挑战。
 *
 * @author Jiajing Li
 * @date 2019-03-05 09:10:51
 */
public class Main {

    public static void main(String[] args) {
        Node head = initTree();
        Print.printTree(head);
    }

    /**
     * 一棵二叉树如下所示：
     *                1
     *            /      \
     *          2         3
     *        /         /  \
     *       4         5   6
     *         \
     *          7
     */
    private static Node initTree() {
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        Node node5 = new Node(5);
        Node node6 = new Node(6);
        Node node7 = new Node(7);

        node1.left = node2;
        node1.right = node3;

        node2.left = node4;
        node3.left = node5;
        node3.right = node6;

        node4.right = node7;

        return node1;
    }

}
