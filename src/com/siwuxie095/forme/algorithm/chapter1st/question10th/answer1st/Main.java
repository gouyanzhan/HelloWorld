package com.siwuxie095.forme.algorithm.chapter1st.question10th.answer1st;

/**
 * 最大值减去最小值小于等于 num 的子数组数量
 *
 * 题目：
 * 给定数组 arr 和整数 num，共返回有多少个子数组满足如下情况：
 * max(arr[i...j]) - min(arr[i...j])  <= num
 * 其中，max(arr[i...j]) 和 min(arr[i...j]) 分别表示子数组arr[i...j]中的最大值和最小值。
 *
 * 要求：如果数组长度为 N，请实现时间复杂度为 O(N) 的解法。
 *
 * 解答：
 * 普通解法就是找到 arr 的所有子数组，数量级是 N^2，对每一个子数组做遍历找到其中的最大值和最小值，
 * 这个过程的时间复杂度是 O(N)，然后再看这个子数组是否满足条件。统计所有满足的子数组数量即可。整体
 * 的时间复杂度是 O(N^3)。
 *
 * 最优解可以做到时间复杂度 O(N)，额外空间复杂度 O(N)。这里借用了双端队列（即 队头和队尾都可以做入队
 * 和出队的操作）。
 *
 * 生成两个双端队列 qmax 和 qmin（里面存的实际是索引），当子数组为 arr[i...j] 时：
 * 1）qmax 维护了窗口子数组 arr[i...j] 的最大值更新的结构，
 * 2）qmin 维护了窗口子数组 arr[i...j] 的最小值更新结构。
 *
 * 当子数组 arr[i...j] 向右扩一个位置变成 arr[i...j+1] 时，qmax 和 qmin 结构可以在 O(1) 的时间
 * 内更新，并且可以在 O(1) 的时间内得到 arr[i...j+1] 的最大值和最小值。同理，当子数组 arr[i...j]
 * 向左缩一个位置变成 arr[i+1...j] 时，也一样。
 *
 * 通过分析题目满足的条件可以得出两个结论：
 * 1）如果子数组 arr[i...j] 满足条件，则 arr[i...j] 中的每一个子数组都满足条件。
 * 2）如果子数组 arr[i...j] 不满足条件，则所有包含 arr[i...j] 的子数组都不满足条件。
 *
 * 根据 qmax 和 qmin 的结构特点以及如上两个结论，可以做如下整个设计：
 * 1、生成两个双端队列 qmax 和 qmin，生成两个整型变量，表示子数组的范围，即 arr[i...j]。生成整型变量 res，
 * 表示所有满足条件的子数组数量。
 * 2、令 j 不断右移（j++），表示 arr[i...j] 一直向右扩大，并不断更新 qmax 和 qmin，保证 qmax 和 qmin
 * 始终维持动态窗口最大值和最小值的更新结构。一旦出现 arr[i...j] 不满足条件的情况，j 停止向右扩。
 * 此时，arr[i...j-1]、arr[i...j-2] ... arr[i]，一定都是满足条件的，也就是说必须以 arr[i] 作为第一个
 * 元素的子数组，满足条件的数量为 (j-1)-i+1 = j-i 个，于是令 res += j-i。
 * 3、当进行完步骤 2，令 i 向右移动一个位置，并对 qmax 和 qmin 做相应的更新。qmax 和 qmin 从原来的 arr[i...j]
 * 变成 arr[i+1...j] 窗口的最大值和最小值的更新结构。然后重复步骤 2，也就是求所有必须以 arr[i+1] 作为第一个
 * 元素的子数组，满足条件的数量有多少个。
 * 4、根据步骤 2 和步骤 3，依次求出以 arr[0]、arr[1] ... arr[N-1] 作为第一个元素的子数组中满足条件的分别有多少
 * 个，累加起来的数量就是最终的结果。
 *
 * 上述过程中，所有的下标（索引）最多进 qmax 和 qmin 一次，出 qmax 和 qmin 一次。i 和 j 的值也在不断累加。并且
 * 从不减小。所以整个过程的时间复杂度是 O(N)。
 *
 * @author Jiajing Li
 * @date 2019-02-09 22:12:15
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        int num = 5;
        int count = Number.getNum(arr, num);
        System.out.println("满足条件的子数组数量 = " + count);
    }

}
