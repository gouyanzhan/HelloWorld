package com.siwuxie095.forme.algorithm.chapter6th.question3rd.answer1st;

/**
 * 40 亿个非负整数中找到没出现的数
 *
 * 题目：
 * 32 位无符号整数的范围是 0～4294967295，现在有一个正好包含 40 亿个无符号整数的文件，
 * 所以在整个范围中必然有没出现过的数。可以使用最多 1GB 的内存，怎么找到所有没出现过的数。
 *
 * 进阶：内存限制为 10MB，但是只用找到一个没出现过的数即可。
 *
 * 解答：
 * 原问题。如果用哈希表来保存出现过的数，那么如果 40 亿个数都不同，则哈希表的记录数为 40
 * 亿条，存一个 32 位整数需要 4B，所以最差情况下需要 40亿 * 4B = 160 亿字节，大约需要
 * 16GB 的空间，这是不符合要求的。
 * 哈希表需要占用很多空间，我们可以使用 bit map 的方式来表示数出现的情况。具体地说，是申
 * 请一个长度为 4294967295 的 bit 类型的数组 bitArr，bitArr 上的每个位置只可以表示 0
 * 或 1 状态。8 个 bit 为 1B，所以长度为 4294967295 的 bit 类型的数组占用 500MB 空间。
 * 怎么使用这个 bitArr 数组呢？就是遍历这 40 亿个无符号数，例如，遇到 7000，就把 bitArr
 * [7000] 设置为 1。遇到所有的数时，就把 bitArr 相应位置的值设置为 1。
 * 遍历完成后，再依次遍历 bitArr，哪个位置上的值没被设置为 1，哪个数就不再 40 亿个数中。
 * 遍历完 bitArr 之后，所有没出现的数就都找出来了。
 *
 * 进阶问题。现在只有 10MB 的内存，但也只要求找到其中一个没出现的数即可。首先，0～4294967295
 * 这个范围是可以平均分成 64 个区间的，每个区间是 67108864 个数，例如：第 0 个区间（0～67108863）、
 * 第 1 个区间（67108864～134217728）、第 i 区间（67108864*i～67108864*(i+1)-1）、第 63
 * 区间（4227858432～4294967295）。因为一共只有 40 个数，所以，如果统计落在每个区间上的数有多
 * 少，肯定只要有一个区间上的计数少于 67108864。利用这一点可以找出其中一个没出现过的数。
 * 具体过程为：
 * 第一次遍历时，先申请长度为 64 的整型数组 countArr[0..63]，countArr[i] 用来统计区间 i 上
 * 的数有多少。遍历 40 亿个数，根据当前数是多少来决定哪一个区间上的计数增加。例如，如果当前数是
 * 3422552090，3422552090/67108864=51，所以第 51 区间上的计数增加 1，即 countArr[51]++。
 * 遍历完 40 亿个数之后，遍历 countArr，必然会有某一个位置上的值（countArr[i]）小于 67108864，
 * 表示第 i 区间上至少有一个数没出现过。我们肯定会至少找到一个这样的区间。此时使用的内存就是 countArr
 * 的大小（64*4B），是非常小的。
 * 假设我们找到第 37 区间上的计数小于 67108864，以下为第二次遍历的过程：
 * 1、申请长度为 67108864 的 bit map，这大约占用 8MB 的空间，记为 bitArr[0..67108863]；
 * 2、再遍历一遍 40 亿个数，此时的遍历只关注落在第 37 区间上的数，记为 num（num/67108864=37），
 * 其他区间的数全部忽略。
 * 3、如果步骤 2 的 num 落在第 37 区间，将 bitArr[num-67108864*37] 的值设置为 1，也就是只做
 * 第 37 区间上的数的 bitArr 映射。
 * 4、遍历完 40 亿个数之后，在 bitArr 上必然存在没被设置成 1 的位置，假设第 i 个位置上的值没设置
 * 成 1，那么 67108864*37+i 这个数就是一个没出现过的数。
 * 总结一下进阶的解法：
 * 1、根据 10MB 的内存限制，确定统计区间的大小，就是第二次遍历时的 bitArr 大小。
 * 2、利用区间计数的方式，找到那个计数不足的区间，这个区间肯定有没出现过的数。
 * 3、对这个区间上的数做 bit map 映射，再遍历 bit map，找到一个没出现的数即可。
 *
 * @author Jiajing Li
 * @date 2019-05-16 14:06:04
 */
public class Main {

}
