package com.siwuxie095.forme.algorithm.chapter6th.question5th.answer1st;

/**
 * 40 亿个非负整数中找到出现两次的数和所有数的中位数
 *
 * 题目：
 * 32 位无符号整数的范围是 0～4294967295，现在有 40 亿个无符号整数，可以使用最多 1GB 的内存，找出
 * 所有出现了两次的数。
 *
 * 补充题目：
 * 可以使用最多 10MB 的内存，怎么找到这 40 亿个整数中的中位数。
 *
 * 解答：
 * 对于原问题，可以使用 bit map 的方式来表示数出现的情况。具体地说，是申请一个长度为 4294967295*2
 * 的 bit 类型的数组 bitArr，用两个位置表示一个数出现的词频，1B 占用 8 个 bit，所以长度为
 * 4294967295*2 的 bit 类型的数组占用了 1GB 空间。怎么使用这个 bitArr 数组呢？遍历这 40 亿个无
 * 符号数，如果初次遇到 num，就把 bitArr[num*2+1] 和 bitArr[num*2] 设置为 01，如果第二次遇到
 * num，就把 bitArr[num*2+1] 和 bitArr[num*2] 设置为 10，如果第三次遇到 num，就把 bitArr[num*2+1]
 * 和 bitArr[num*2] 设置为 11。以后再遇到 num，发现此时 bitArr[num*2+1] 和 bitArr[num*2]
 * 已经被设置为 11，就不再做任何设置。遍历完成后，再次遍历 bitArr，如果发现 bitArr[num*2+1] 和
 * bitArr[num*2] 设置为 10，那么 i 就是出现了两次的数。
 *
 * 对于补充问题，用分区间的方式处理，长度为 2MB 的无符号整型数组占用的空间为 8MB，所以将区间的数量定
 * 为 4294967295/2M，向上取整为 2148 个区间。第 0 个区间为 0～2M-1，第 1 个区间为 2M～4M-1，
 * 第 i 个区间为 2M*i～2M*(i+1)-1 ...
 * 申请一个长度为 2148 的无符号整型数组 arr[0..2147]，arr[i] 表示第 i 区间有多少个数。arr 必然
 * 小于 10MB。然后遍历 40 亿个数，如果遍历到当前数为 num，先看 num 落在哪个区间上（num/2M），然后
 * 将对应的进行 arr[num/2m]++ 操作。这样遍历下来，就得到了每一个区间的数的出现状况，通过累加每个区间
 * 的出现次数，就可以找到 40 亿个数的中位数（也就是第 20 亿个数）到底落在哪个区间上。比如，0～K-1 区
 * 间上数的个数为 19.998 亿，但是发现当加上第 K 个区间上数第个数之后就超过了 20 亿，那么可以知道第 20
 * 亿个数是第 K 区间上的数，并且可以知道第 20 亿个数是第 K 区间上的第 0.002 亿个数。
 * 接下来申请一个长度为 2MB 的无符号整型数组 countArr[0..2M-1]，占用空间 8MB。然后再遍历 40 亿个
 * 数，此时只关心处在第 K 区间的数记为 numi，其他的数省略，然后将 countArr[numi-K*2M]++，也就是只
 * 对第 K 区间的数做频率统计。这次遍历完 40 亿个数之后，就得到了第 K 区间的词频统计结果 countArr，
 * 最后只在第 K 区间上找到第 0.002 亿个数即可。
 *
 * @author Jiajing Li
 * @date 2019-05-17 10:17:45
 */
public class Main {

}
