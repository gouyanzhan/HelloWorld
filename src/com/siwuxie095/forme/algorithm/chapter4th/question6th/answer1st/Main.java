package com.siwuxie095.forme.algorithm.chapter4th.question6th.answer1st;

/**
 * 汉诺塔问题
 *
 * 题目：
 * 给定一个整数 n，代表汉诺塔游戏中从小到大放置到 n 个圆盘，假设开始时所有的圆盘都放在左边的柱子上，
 * 想按照汉诺塔游戏的要求把所有的圆盘都移到右边的柱子上。实现函数打印最优移动轨迹。
 *
 * 比如：
 * n = 1 时，打印：
 * move from left to right
 * n = 2 时，打印：
 * move from left to mid
 * move from left to right
 * move from mid to right
 *
 * 进阶题目：
 * 给定一个整型数组 arr，其中只含有 1、2、3，代表所有圆盘目前的状态，1 代表左柱，2 代表中柱，3 代
 * 表右柱，arr[i] 的值代表第 i+1 个圆盘的位置。比如，arr = [3, 3, 2, 1]，代表第 1 个圆盘在右柱
 * 上、第 2 个圆盘在右柱上、第 3 个圆盘在中柱上、第 4 个圆盘在左柱上。如果 arr 代表的状态是最优移
 * 动轨迹过程中出现的状态，返回 arr 这种状态是最优移动轨迹中的第几个状态。如果 arr 代表的状态不是最
 * 优移动轨迹过程中出现的状态，则返回 -1。
 *
 * 比如：
 * arr = [1, 1]。两个圆盘目前都在左柱上，也就是初始状态，所以返回 0。
 * arr = [2, 1]。第一个圆盘在中柱上、第二个圆盘在左柱上，这个状态是 2 个圆盘的汉诺塔游戏中最优移动
 * 轨迹的第 1 步，所以返回 1。
 * arr = [3, 3]。第一个圆盘在右柱上、第二个圆盘在右柱上，这个状态是 2 个圆盘的汉诺塔游戏中最优移动
 * 轨迹的第 3 步，所以返回 3。
 * arr = [2, 2]。第一个圆盘在中柱上、第二个圆盘在中柱上，这个状态是 2 个圆盘的汉诺塔游戏中最优移动
 * 轨迹从来不会出现的状态，所以返回 -1。
 *
 * 进阶题目要求：如果 arr 长度为 N，请实现时间复杂度为 O(N)、额外空间复杂度为 O(1) 的方法。
 *
 * 解答：
 * 原问题。假设有 from 柱子、mid 柱子和 to 柱子，都在 from 的圆盘 1～i 完全移动到 to，最优过程为：
 * 步骤 1 为圆盘 1～i 从 from 移动到 mid。
 * 步骤 2 为单独把圆盘 i 从 from 移动到 to。
 * 步骤 3 为把圆盘 1～i-1 从 mid 移动到 to。如果圆盘只有 1 个，直接把这个圆盘从 from 移动到 to
 * 上即可。
 * 具体代码请参看 hanoi() 方法。
 *
 * 进阶问题。首先求都在 from 柱子上的圆盘 1～i，如果都移动到 to 上的最少步骤数，假设为 S(i)。根据上
 * 面的步骤，S(i) = 步骤 1 的步骤总数 + 1 + 步骤 3 中的步骤总数 = S(i-1) + 1 + S(i-1)，S(1) =
 * 1。所以 S(i) + 1 = 2(S(i-1) + 1)，S(1) + 1 == 2。根据等比数列求和公式得到 S(i) + 1 = 2^i，
 * 所以 S(i) = 2^(i-1)。
 * 对于数组 arr 来说，arr[N-1] 表示最大圆盘 N 在哪个柱子上，情况有以下三种：
 * （1）圆盘 N 在左柱上，说明步骤 1 或者没有完成，或者已经完成，需要考查圆盘 1～N-1 的状况。
 * （2）圆盘 N 在右柱上，说明步骤 1 已经完成，起码走完了 2^N - 1 步。步骤 2 也已经完成，起码又走完了
 * 1 步，所以当前状况起码是最优步骤的 2^(N-1) 步，剩下的步骤怎么确定还得继续考查圆盘 1～N-1 的状况。
 * （3）圆盘 N 在中柱上，这是不可能的，最优步骤中不可能让圆盘 N 处在中柱上，直接返回 -1。
 *
 * 所以整个过程可以总结为：对圆盘 1～i 来说，如果目标为从 from 到 to，那么情况有三种：
 * （1）圆盘 i 在 from 上，需要继续考查圆盘 1～i-1 的状况，圆盘 1～i-1 的目标为从 from 到 mid。
 * （2）圆盘 i 在 to 上，说明起码走完了 2^(i-1) 步，剩下的步骤怎么确定还得继续考查圆盘 1～i-1 的状况，
 * 圆盘 1～i-1 的目标为从 mid 到 to。
 * （3）圆盘 i 在 mid 上，直接返回 -1。
 * 具体代码请参看 step1() 方法。
 *
 * step1() 方法是递归函数，递归最多调用 N 次，并且每步的递归函数再调用递归函数的次数最多一次。在每个
 * 递归过程中，除去递归调用的部分，剩下过程的时间复杂度为 O(1)，所以 step1() 方法的时间复杂度为 O(N)。
 * 但是因为递归函数需要函数栈的关系，step1() 方法的额外空间复杂度为 O(N)，所以为了达到题目的要求需要
 * 将整个过程改成非递归的方法。
 * 具体代码请参看 step2() 方法。
 *
 * @author Jiajing Li
 * @date 2019-04-06 13:26:36
 */
public class Main {

    public static void main(String[] args) {
        HanoiTower.hanoi(3);
        int[] arr = new int[] {3, 2, 1};
        System.out.println(HanoiTower.step1(arr));
        System.out.println(HanoiTower.step2(arr));
    }

}
