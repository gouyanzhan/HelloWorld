package com.siwuxie095.forme.algorithm.chapter4th.question4th.answer1st;

/**
 * 换钱的方法数
 *
 * 题目：
 * 给定数组 arr，arr 中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用
 * 任意张，再给定一个整数 aim 代表要找的钱数，求换钱有多少种方法。
 *
 * 比如：
 * arr = [5, 10, 25, 1]，aim = 0。
 * 组成 0 元的方法有 1 种，就是所有面值的货币都不用。所以返回 1。
 * arr = [5, 10, 25, 1]，aim = 15。
 * 组成 15 元的方法有 6 种，分别为：3 张 5 元、1 张 10 元 + 1 张 5 元、1 张 10 元 + 5 张 1 元、
 * 10 张 1 元 + 1 张 5 元、2 张 5 元 + 5 张 1 元、15 张 1 元，所以返回 6。
 * arr = [3, 5]，aim = 2。
 * 任何方法都无法组成 2 元，所以返回 0。
 *
 * 解答：
 * 这里将由浅入深地给出所有的解法，最后解释最优解。这道题的经典之处在于它可以体现暴力递归、记忆搜索、
 * 动态规划之间的关系，并可以在动态规划的基础上进行再一次的优化。其实在面试中出现的大量暴力递归的题
 * 目都有相似的优化轨迹。
 *
 * 1、首先介绍暴力递归的方法。如果 arr = [5, 10, 25, 1]，aim = 1000，分析过程如下：
 * （1）用 0 张 5 元的货币，让 [10, 25, 1] 组成剩下的 1000，最终方法数记为 res1。
 * （2）用 1 张 5 元的货币，让 [10, 25, 1] 组成剩下的 995，最终方法数记为 res2。
 * （3）用 2 张 5 元的货币，让 [10, 25, 1] 组成剩下的 990，最终方法数记为 res3。
 *  ...
 * （201）用 200 张 5 元的货币，让 [10, 25, 1] 组成剩下的 0，最终方法数记为 res201。
 *
 *  那么 res1 + res2 + ... + res201 的值就是总的方法数。根据如上的分析过程定义递归函数 process1
 *  (arr, index, aim)，它的含义是如果用 arr[index...N-1] 这些面值的钱组成 aim，返回总的方法数。
 *  具体代码请参看 coins1() 方法。
 *
 *
 *  2、接下来介绍暴力递归的初步优化的方法，也就是记忆搜索的方法。暴力递归之所以暴力，是因为存在大量的
 *  重复计算。比如上面的例子，当已经使用 0 张 5 元 + 1 张 10 元的情况下，后续应该求 [25, 1] 组成
 *  剩下的 990 的方法总数。当已经使用 2 张 5 元 + 0 张 10 元的情况下，后续还是求 [25, 1] 组成剩
 *  下的 990 的方法总数。两种情况下都需要求 process1(arr, 2, 990)。类似这样的重复计算在暴力递归
 *  的过程中大量发生，所以暴力递归方法的时间复杂度非常高，并且与 arr 中钱的面值有关，最差情况下为 O(aim^N)。
 *
 *  记忆化搜索的优化方式。process1(arr, index, aim) 中 arr 是始终不变的，变化的只有 index 和
 *  aim，所以可以用 p(index, aim) 表示一个递归过程。重复计算之所以大量发生，是因为每个递归过程的
 *  结果都没记下来，所以下次还要重复去求。所以可以事先准备好一个 map，每计算完一个递归过程，都将结果
 *  记录到 map 中。当下次进行同样的递归过程之前，先在 map 中查询这个递归过程是否已经计算过，如果已
 *  经计算过，就把值拿出来直接用，如果没计算过，需要再进入递归过程。具体代码请参看 coins2() 方法。
 *  它和 coins1() 方法的区别就是准备好全局变量 map，记录已经计算过的递归过程的结果，防止下次重复计
 *  算。因为本题的递归过程可由两个变量表示，所以 map 是一张二维表。map[i][j] 表示递归过程 p(i, j)
 *  的返回值。另外有一些特别值，map[i][j] == 0 表示递归过程 p(i, j) 从来没有计算过。map[i][j]
 *  == -1 表示递归过程 p(i, j) 计算过，但返回值是 0。如果 map[i][j] 的值既不等于 0，也不等于 -1，
 *  记为 a，则表示递归过程 p(i, j) 的返回值为 a。
 *
 *  记忆化搜索的方法是针对暴力递归最初级的优化技巧，分析递归函数的状态可以由哪些变量表示，做出相应维度
 *  和大小的 map 即可。记忆化搜索方法的时间复杂度为 O(N * aim^2)，解释完下面的方法后，再来具体解释
 *  为什么是这个时间复杂度。
 *
 *
 *  3、动态规划方法 A。生成行数为 N、列数为 aim+1 的矩阵 dp，dp[i][j] 的含义是在使用 arr[0...i]
 *  货币的情况下，组成钱数 j 有多少种方法。dp[i][j] 的值求法如下：
 *  （1）对于矩阵 dp 第一列的值 dp[..][0]，表示组成钱数为 0 的方法数，很明显是 1 种，也就是不使用
 *  任何货币。所以 dp 第一列的值统一设为 1。
 *  （2）对于矩阵 dp 第一行的值 dp[0][..]，表示只能使用 arr[0] 这一种货币的情况下，组成钱的方法数，
 *  比如，arr[0] == 5 时，能组成的钱数只有 0、5、10、15 ... 所以，令 dp[0][k*arr[0]] = 1，其中，
 *  0 <= k*arr[0] <= aim，k 为非负整数。
 *  （3）除第一行和第一列的其他位置，记为位置 (i, j)，dp[i][j] 的值是以下几个值的累加。
 *  1）完全不用 arr[i] 货币，只使用 arr[0...i-1] 货币时，方法数为 dp[i-1][j]。
 *  2）用 1 张 arr[i] 货币，剩下的钱用 arr[0...i-1] 货币组成时，方法数为 dp[i-1][j-arr[i]]。
 *  3）...
 *  4）用 k 张 arr[i] 货币，剩下的钱用 arr[0...i-1] 货币组成时，方法数为 dp[i-1][j-k*arr[i]]。
 *  （4）最终 dp[N-1][aim] 的值就是最终结果。
 *  具体代码请参看 coins3() 方法。
 *
 *  在最差的情况下，对位置 (i, j) 来说，求解 dp[i][j] 的计算过程需要枚举 dp[i-1][0..j] 上的所有
 *  值，dp 一共有 N*aim 个位置，所以总体的时间复杂度为 O(N * aim^2)。
 *  下面解释之前记忆化搜索方法的时间复杂度为什么也是 O(N * aim^2)，因为在本质上记忆化搜索方法等价于
 *  动态规划方法。记忆化搜索的方法说白了就是不关心到达某一个递归过程的路径，只是单纯地对计算过的递归过
 *  程进行记录，避免重复的递归过程，而动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，
 *  后计算的过程严格依赖前面计算过的过程。两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规
 *  划规定计算顺序，而记忆搜索不用规定。所以记忆化搜索方法的时间复杂度也是 O(N * aim^2)。两者各有优
 *  缺点，如果对暴力递归过程简单地优化成记忆搜索的方法，递归函数依然在使用，这在工程上开销较大。而动态
 *  规划方法严格规定了计算顺序，可以将递归计算变成顺序计算，这是动态规划方法具有的优势。其实记忆搜索的
 *  方法也有优势，本题就很好的体现了，比如：arr = [20000, 10000, 1000]，aim = 20 0000 0000。
 *  如果是动态规划的计算方法，要严格计算 3 * 20 0000 0000 个位置。而对于记忆搜索来说，因为面值最小
 *  的钱为 1000，所以百位为（1～9）、十位为（1～9）或个位为（1～9）的钱数是不可能出现的，当然也就不
 *  必要计算。通过本例可以知道，记忆化搜索是对必须要计算的递归过程才去计算并记录的。
 *
 *
 *  4、动态规划方法 B。它的时间复杂度为 O(N * aim)。在动态规划方法 A 中，求 dp[i][j] 值的时候的步
 *  骤 （3），这也是最关键的枚举过程。这个过程中，第一种情况的方法数为 dp[i-1][j]，而第二种情况的一直
 *  到第 k 种情况的方法数累加值其实就是 dp[i][j-arr[i]] 的值。所以步骤 （3） 可以简化为 dp[i][j]
 *  = dp[i-1][j] + dp[i][j-arr[i]]。一下省去了枚举的过程，时间复杂度也减小至 O(N * aim)。
 *  具体代码请参看 coins4() 方法。
 *
 *
 *  5、动态规划方法 B + 空间压缩。也就是最优解：时间复杂度为 O(N * aim)，额外空间复杂度为 O(aim)。
 *
 *
 *  扩展：
 *  通过本题目的优化过程，可以梳理出暴力递归通用的优化过程。对于在面试中遇到的具体题目，面试者一旦想到
 *  暴力递归的过程，其实之后的优化都是水到渠成的。首先看写出来的暴力递归函数，找到有哪些参数是不发生变
 *  化的，忽略这些变量。只看那些变化并且可以表示递归过程的参数，找出这些参数之后，记忆搜索的方法其实可
 *  以很轻易的写出来，因为只是简单的修改，计算完就记录到 map 中，并在下次直接拿来使用，没计算过则依然
 *  进行递归计算。接下来观察记忆搜索过程中使用的 map 结构，看看该结构某一个具体位置的值是通过哪些位置
 *  的值求出的，被依赖的位置先求，就能改出动态规划的方法。改出的动态规划方法中，如果有枚举的过程，看看
 *  枚举过程是否可以继续优化，常规方法既有本题所实现的通过表达式来化简枚举状态的方式，也有 "丢棋子问题"、
 *  "画匠问题" 和 "邮局选址问题" 所涉及的四边形不等式的相关内容。
 *
 * @author Jiajing Li
 * @date 2019-04-03 18:34:07
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = new int[] {5, 10, 25, 1};
        int aim = 1000;
        System.out.print("1、暴力递归方法：");
        System.out.println(Coin.coins1(arr, aim));
        System.out.print("2、记忆搜索方法：");
        System.out.println(Coin.coins2(arr, aim));
        System.out.print("3、动态规划方法 A：");
        System.out.println(Coin.coins3(arr, aim));
        System.out.print("4、动态规划方法 B：");
        System.out.println(Coin.coins4(arr, aim));
        System.out.print("5、动态规划方法 B + 空间压缩：");
        System.out.println(Coin.coins5(arr, aim));
    }

}
