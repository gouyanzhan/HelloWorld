package com.siwuxie095.forme.algorithm.chapter4th.question1st.answer1st;

/**
 * 斐波那契系列问题的递归和动态规划
 *
 * 题目：
 * 给定整数 N，返回斐波那契数列的第 N 项。
 *
 * 补充题目 1：
 * 给定整数 N，代表台阶数，一次可以跨 2 个或者 1 个台阶，返回有多少种走法。
 * 如：N = 3，可以三次都跨一个台阶；也可以先跨 2 个台阶，再跨 1 个台阶；还
 * 可以先跨 1 个台阶，再跨 2 个台阶。所以有三种走法，返回 3。
 *
 * 补充题目 2：
 * 假设农场中成熟的母牛每年只会生 1 头小母牛，并且永远不会死。第一年农场有 1
 * 只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可
 * 以生小母牛。给定整数 N，求出 N 年后牛的数量。
 * 如：N = 6，第 1 年 1 头成熟母牛记为 a；第 2 年 a 生了新的小母牛，记为 b，
 * 总牛数为 2；第 3 年 a 生了新的小母牛，记为 c，总牛数为 3；第 4 年 a 生了
 * 新的小母牛，记为 d，总牛数为 4。第 5 年 b 成熟了，a 和 b 分别生了新的小母
 * 牛，总牛数为 6；第 6 年 c 也成熟了，a、b、c 分别生了新的小母牛，总牛数为 9，
 * 返回 9。
 *
 * 要求：对以上所有的问题，请实现时间复杂度 O(logN) 的解法。
 *
 * 解答：
 * 1、原问题。
 * （1）O(2^N) 的方法。斐波那契数列为 1，1，2，3，5，8，...，也就是除第 1 项
 * 和第 2 项为 1 外，对于第 N 项，有 F(N) = F(N-1) + F(N-2)，于是很轻松地
 * 写出暴力递归第代码。请参看 fun1() 方法。
 * （2）O(N) 的方法。斐波那契数列可以从左到右依次求出每一项的值，那么通过顺序计
 * 算到第 N 项即可。请参看 fun2() 方法。
 * （3）O(logN) 的方法。如果递归式严格遵循 F(N) = F(N-1) + F(N-2)，对于求
 * 第 N 项的值，有矩阵乘法的方式可以将时间复杂度降低至 O(logN)。请参看 fun3()
 * 方法。
 * F(N) = F(N-1) + F(N-2) 是一个二阶递归数列，一定可以用矩阵乘法的形式表示，
 * 且状态矩阵为 2 * 2 的矩阵。把前四项代入，求出状态矩阵。
 *
 * 所以，求斐波那契数列第 N 项的问题就变成了如何用最快的方法求一个矩阵的 N 次方
 * 的问题，而求矩阵 N 次方的问题明显是一个能够在 O(logN) 时间内解决的问题。为
 * 了表述方便，现在用求一个整数 N 次方的例子来说明，因为只要理解了如何在 O(logN)
 * 的时间复杂度内求整数 N 次方的问题，对于求矩阵 N 次方的问题是同理的，区别是矩
 * 阵乘法和整数乘法在细节上有些不一样，但对于怎么乘更快，两者的道理相同。
 *
 * 假设一个整数是 10，如何最快地求解 10 的 75 次方。
 * 1）75 的二进制数形式为 1001011。
 * 2）10 的75 次方 = 10^64 * 10^8 * 10^2 * 10^1。
 * 在这个过程中，先求出 10^1，然后根据 10^1 求出 10^2，再根据 10^2 求出 10^4，
 * ...，最后根据 10^32 求出 10^64，即 75 的二进制数形式总共有多少位，就使用几次
 * 乘法。
 * 3）在步骤 2）进行的过程中，把应该累乘的值相乘即可，比如 10^64、10^8、10^2、10^1
 * 应该累乘，因为 64、8、2、1 对应到 75 的二进制数中，相应的位上是 1，而 10^32、10^16、
 * 10^4 不应该累乘，因为 32、16、4 对应到 75 的二进制数中，相应的位上是 0。
 *
 * 对矩阵来说同理，求矩阵 m 的 p 次方请参看 matrixPower() 方法，其中 multiMatrix()
 * 方法是两个矩阵相乘的具体实现。
 *
 * 2、补充问题 1
 * 如果台阶只有 1 级，方法只有 1 种。如果台阶有 2 级，方法有 2 种。如果台阶有
 * N 级，最后跳上第 N 级的情况，要么是从 N-2 级台阶直接跨 2 级台阶，要么是从
 * N-1 级台阶跨 1 级台阶，所以台阶有 N 级的方法数为跨到 N-2 级台阶的方法数加
 * 上跨到 N-1 级台阶的方法数，即 S(N) = S(N-1) + S(N-2)，初始项 S(1) = 1，
 * S(2) = 2。所以类似斐波那契数列，唯一不同的就是初始项不同。可以很轻易地写出
 * O(2^N) 与 O(N) 的方法，请参看 foo1() 和 foo2() 方法。
 * O(logN) 的方法。S(N) = S(N-1) + S(N-2) 是一个二阶递归数列，同样用上文
 * 矩阵乘法的方法，根据前四项求出状态矩阵。请参看 foo3() 方法。
 *
 * 3、补充问题 2
 * 所有的牛都不会死，所以第 N-1 年的牛会毫无损失地活到第 N 年。同时所有成熟的
 * 牛都会生 1 头新的牛，那么成熟牛的数量如何估计？就是第 N-3 年的所有牛，到第
 * N 年肯定都是成熟的牛，其间出生的牛肯定都没有成熟。所以 C(N) = C(N-1) +
 * C(N-3)，初始项 C(1) = 1，C(2) = 2，C(3) = 3。这个和斐波那契数列也十分
 * 类似，只不过 C(N) 依赖 C(N-1) 和 C(N-3) 的值，而斐波那契数列 F(N) 依赖
 * F(N-1) 和 F(N-2) 的值，同样可以写出 O(2^N) 与 O(N) 的方法。请参看 bar1()
 * 和 bar2() 方法。
 * O(logN) 的方法。C(N) = C(N-1) + C(N-3) 是一个三阶递推数列，一定可以用
 * 矩阵乘法的形式表示，且状态矩阵为 3 * 3 的矩阵。把前五项代入，求出状态矩阵。
 * 请参看 bar3() 方法。
 *
 *
 * 如果递归式严格符合 F(n) = a * F(n-1) + b * F(n-2) + ... + k * F(n-i)，
 * 那么它就是一个 i 阶的递推式，必然有与 i*i 的状态矩阵有关的矩阵乘法的表达式。一
 * 律可以用加速矩阵乘法的动态规划将时间复杂度降为 O(logN)。
 *
 * @author Jiajing Li
 * @date 2019-03-31 18:10:03
 */
public class Main {

    public static void main(String[] args) {
        System.out.println("原问题：");
        System.out.println(FibonacciSerie.fun1(10));
        System.out.println(FibonacciSerie.fun2(10));
        System.out.println(FibonacciSerie.fun3(10));
        System.out.println();
        System.out.println("补充问题 1：");
        System.out.println(FibonacciSerie.foo1(10));
        System.out.println(FibonacciSerie.foo2(10));
        System.out.println(FibonacciSerie.foo3(10));
        System.out.println();
        System.out.println("补充问题 2：");
        System.out.println(FibonacciSerie.bar1(10));
        System.out.println(FibonacciSerie.bar2(10));
        System.out.println(FibonacciSerie.bar3(10));
    }

}
