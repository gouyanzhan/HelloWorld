package com.siwuxie095.forme.algorithm.chapter4th.question3rd.answer1st;

/**
 * 换钱的最少货币数
 *
 * 题目：
 * 给定数组 arr，arr 中所有的值都为正数且不重复。每个值都代表一种面值的货币，每种面值的货币
 * 可以使用任意张，再给定一个整数 aim 代表要找的钱数，求组成 aim 的最少货币数。
 *
 * 例如：
 * arr = [5, 2, 3]，aim = 20。
 * 4 张 5 元可以组成 20 元，其它的找钱方案都要使用更多张的货币，所以返回 4。
 * arr = [5, 2, 3]， aim = 0。
 * 不用任何货币就可以组成 0 元，返回 0。
 * arr = [3, 5]，aim = 2。
 * 根本无法组成 2 元，钱不能找开的情况下，默认返回 -1。
 *
 * 补充题目：
 * 给定数组 arr，arr 中所有的值都为正数，每个值仅代表一张钱的面值，再给定一个整数 aim 代表
 * 要找的钱数，求组成 aim 的最少货币数。（相对于上面，其实就是 arr 中的值可以重复，且已经是
 * 全部的钱）
 *
 * 例如：
 * arr = [5, 2, 3]，aim = 20。
 * 5 元、2 元和 3 元的钱各有 1 张，所以无法组成 20 元，默认返回 -1。
 * arr = [5, 2, 5, 3]，aim = 10。
 * 5 元的货币有 2 张，可以组成 10 元，且该方案所需张数最少，返回 2。
 * arr = [5, 2, 5, 3]，aim = 15。
 * 所有的钱加起来才能组成 15 元，返回 4。
 * arr = [5, 2, 5, 3]，aim = 0。
 * 不用任何货币就可以组成 0 元，返回 0。
 *
 * 解答：
 * 原问题的经典动态规划方法。如果 arr 的长度为 N，生成行数为 N、列数为 aim+1 的动态规划表
 * 的 dp。dp[i][j] 的含义是，在可以任意使用 arr[0...i] 货币的情况下，组成 j 所需的最小
 * 张数。根据这个定义，dp[i][j] 的值按如下方式计算：
 * 1、dp[0...N-1][0] 的值（即 dp 矩阵中第一列的值）表示找的钱数为 0 时需要的最少张数，钱
 * 数为 0 时，完全不需要任何货币，所以全设为 0 即可。
 * 2、dp[0][0...aim] 的值（即 dp 矩阵中第一行的值）表示只能使用 arr[0] 货币的情况下，找
 * 某个钱数的最小张数。比如：arr[0] = 2，那么能找开的钱数为 2、4、6、8...所以令 dp[0][2]
 * = 1，dp[0][4] = 2，dp[0][6] = 3 ... 第一行其他位置所代表的钱数一律找不开，所以一律设
 * 为 32 位整数的最大值，记这个值为 max。
 * 3、剩下的位置依次从左到右，再从上到下计算。假设计算到位置 (i,j)，dp[i][j] 的值可能来自下
 * 面的情况。
 * （1）完全不使用当前货币 arr[i] 情况下的最少张数，即 dp[i-1][j] 的值。
 * （2）只使用 1 张当前货币 arr[i] 情况下的最少张数，即 dp[i-1][j - arr[i]] + 1。
 * （3）只使用 2 张当前货币 arr[i] 情况下的最少张数，即 dp[i-1][j - 2*arr[i]] + 2。
 * （4）只使用 3 张当前货币 arr[i] 情况下的最少张数，即 dp[i-1][j - 3*arr[i]] + 3。
 *
 * 所有的情况中，最终取张数最小的。所以：
 * dp[i][j] = min{dp[i-1][j-k*arr[i]] + k}，其中 k >= 0。
 * 可以推出：
 * 1）dp[i][j] = min{dp[i-1][j], min{dp[i-1][j - x * arr[i]] + x}}，其中 x >= 1。
 * 2）dp[i][j] = min{dp[i-1][j], min{dp[i-1][j - arr[i] - y * arr[i]] + y + 1}}，
 * 其中 y >= 0。
 *
 * 又有 min{dp[i-1][j - arr[i] - y * arr[i]] + y}，其中 y >= 0，可以推出 dp[i][j-arr[i]]，
 * 所以，最终有 dp[i][j] = min{dp[i-1][j], dp[i][j-arr[i]] + 1}。如果 j-arr[i] < 0，
 * 即 发生了越界，说明 arr[i] 太大，用一张都会超出钱数 j，令 dp[i][j] = dp[i-1][j] 即可。
 * 整个过程的时间复杂度和额外空间复杂度都为 O(N*aim)，N 为 arr 的长度。
 * 具体代码请参看 minCoins1() 方法。
 *
 * 原问题在动态规划基础上的空间压缩方法。这里选择生成一个长度为 aim+1 的动态规划一维数组 dp，
 * 然后按行来更新 dp 即可。之所以不选择按列更新，是因为根据 dp[i][j] = min{dp[i-1][j],
 * dp[i][j-arr[i]]+1} 可知，位置 (i, j) 依赖位置 (i-1, j)，即往上跳一下的位置，也依赖位
 * 置 (i, j-arr[i])，即 往左跳 arr[i] 一下的位置，所以按行更新只需要 1 个一维数组，按列更
 * 新需要的一维数组的个数就与 arr 中货币的最大值有关，如最大的货币为 a，说明最差情况下向左侧
 * 跳 a 下，相应地，就要准备 a 个一维数组不断滚动复用，这样实现起来很麻烦，所以不采用按列更新
 * 的方式。空间压缩之后的时间复杂度为 O(N*aim)，额外空间复杂度为 O(aim)。
 * 具体代码请参看 minCoins1() 方法。
 *
 *
 * 补充问题的经典动态规划方法。如果 arr 的长度为 N，生成行数为 N、列数为 aim+1 的动态规划表
 * dp。dp[i][j] 的含义是，在可以任意使用 arr[0...i] 货币的情况下（每个值仅代表一张货币），
 * 组成 j 所需的最小张数。根据这个定义，dp[i][j] 的值按如下方式计算：
 * 1、dp[0...N-1][0] 的值（即 dp 矩阵中第一列的值）表示找的钱数为 0 时需要的最少张数，钱数
 * 为 0 时完全不需要任何货币，所以全设为 0 即可。
 * 2、dp[0][0...aim] 的值（即 dp 矩阵中第一行的值）表示只能使用一张 arr[0] 货币的情况下，
 * 找某个钱数的最小张数。比如 arr[0] = 2，那么能找开的钱数仅为 2，所以令 dp[0][2] = 1。因
 * 为只有一张钱，所以其他位置所代表的钱数一律找不开，一律设为 32 位整数的最大值。
 * 3、剩下的位置依次从左到右、再从上到下计算。假设计算到位置 (i, j)，dp[i][j] 的值可能来自下
 * 面两种情况：
 * （1）dp[i-1][j] 的值代表在可以任意使用 arr[0...i-1] 货币的情况下，组成 j 所需的最小张数。
 * 可以任意使用 arr[0...i] 货币的情况当然包括不使用这一张面值为 arr[i] 的货币，而只任意使用
 * arr[0...i-1] 货币的情况，所以 dp[i][j] 的值可能等于 dp[i-1][j]。
 * （2）因为 arr[i] 只有一张不能重复使用，所以考虑 dp[i-1][j-arr[i]] 的值，这个值代表在可以
 * 任意使用 arr[0...i-1] 货币的情况下，组成 j-arr[i] 所需的最小张数。从钱数为 j-arr[i] 到
 * 钱数 j，只用再加上当前的这张 arr[i] 即可。所以 dp[i][j] 的值可能等于 dp[i-1][j-arr[i]] + 1。
 * 4、如果 dp[i-1][j-arr[i]] 中 j-arr[i] < 0，也就是位置越界了，说明 arr[i] 太大，只用一
 * 张都会超过钱数 j，令 dp[i][j] = dp[i-1][j] 即可。否则 dp[i][j] = min{dp[i-1][j],
 * dp[i-1][j-arr[i]]+1}。整个过程的时间复杂度与额外空间复杂度都为 O(N*aim)。
 * 具体代码请参看 minCoins3() 方法。
 *
 * 补充问题在动态规划基础上的空间压缩方法。这里选择生成一个长度为 aim+1 的动态规划一维数组 dp，
 * 然后按行来更新 dp 即可，不选按列更新的方式与原问题同理。空间压缩之后时间复杂度为 O(N*aim)，
 * 额外空间复杂度为 O(aim)。
 * 具体代码请参看 minCoins4() 方法。
 *
 * @author Jiajing Li
 * @date 2019-04-02 21:40:16
 */
public class Main {

    public static void main(String[] args) {
        int[] arr12 = new int[] {5, 2, 3};
        System.out.println(Coin.minCoins1(arr12, 20));
        System.out.println(Coin.minCoins2(arr12, 20));
        System.out.println();
        int[] arr34 = new int[] {5, 2, 5, 3};
        System.out.println(Coin.minCoins3(arr34, 15));
        System.out.println(Coin.minCoins4(arr34, 15));
    }

}
