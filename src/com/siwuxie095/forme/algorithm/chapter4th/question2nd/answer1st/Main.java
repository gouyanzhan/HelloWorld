package com.siwuxie095.forme.algorithm.chapter4th.question2nd.answer1st;

/**
 * 矩阵的最小路径和
 *
 * 题目：
 * 给定一个矩阵 m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有数字
 * 累加起来就是路径和，返回所有的路径中最小的路径和。
 *
 * 举例，一个矩阵如下：
 * 1    3   5   9
 * 8    1   3   4
 * 5    0   6   1
 * 8    8   4   0
 * 路径 1、3、1、0、6、1、0 是所有路径中路径和最小的，所以返回 12。
 *
 * 解答：
 * 经典动态规划方法。假设矩阵 m 的大小为 M*N，行数为 M，列数为 N。先生成大小和 m 一样的矩
 * 阵 dp，dp[i][j] 的值表示从左上角（即 (0, 0)）位置走到 (i, j) 位置的最小路径和。对 m
 * 的第一行的所有位置来说，即 (0, j) （0<= j < N），从 (0, 0) 位置走到 (0, j) 位置只能
 * 向右走，所以 (0, 0) 位置到 (0, j) 位置的路径和就是 m[0][0...j] 这些值的累加结果。同
 * 理，对 m 的第一列的所有位置来说，即 (i, 0)（0<= i < M），从 (0, 0) 位置走到 (i, 0)
 * 位置只能向下走，所以 (0, 0) 位置到 (i, 0) 位置的路径和就是 m[0...i][0] 这些值的累加
 * 结果。也就是求出了 dp 的第一行和第一列：
 * 1    4   9   18
 * 9
 * 14
 * 22
 *
 * 除第一行和第一列的其它位置 (i, j)，都有左边位置 (i, j-1) 和 上边位置 (i-1, j)。从
 * (0, 0) 到 (i, j) 的路径必然经过 (i, j-1) 或 (i-1, j)，所以有：
 * dp[i][j] = min{dp[i][j-1], dp[i-1][j]} + m[i][j]
 * 含义是比较从 [0][0] 位置开始，经过 [i][j-1] 位置最终到达 (i, j) 的最小路径和经过
 * [i-1][j] 位置最终到达 (i, j) 的最小路径之间，哪条路径的路径和更小。那么更小的路径和就
 * 是 dp[i][j] 的值。所以，最终生成的 dp 矩阵如下：
 * 1    4   9   18
 * 9    5   8   12
 * 14   5   11  12
 * 22   13  15  12
 * 除第一行和第一列之外，每一个位置都考虑从左边到达自己的路径和更小还是从上边到达自己的路径
 * 和更小。最右下角的值就是整个问题的答案。
 *
 * 矩阵中一共有 M*N 个位置，每个位置都计算一次从 (0, 0) 位置达到自己的最小路径和，计算的
 * 时候只是比较左边位置的最小路径和与上边位置的最小路径和哪个更小，所以时间复杂度为 O(M*N)，
 * dp 矩阵的大小为 M*N，所以额外空间复杂度为 O(N*N)。
 *
 * @author Jiajing Li
 * @date 2019-04-01 21:31:50
 */
public class Main {

    public static void main(String[] args) {
        int[][] m = new int[][]{
                {1, 3, 5, 9},
                {8, 1, 3, 4},
                {5, 0, 6, 1},
                {8, 8, 4, 0}
        };
        System.out.println("矩阵的最小路径和 = " + Path.minPathSum(m));
    }

}
