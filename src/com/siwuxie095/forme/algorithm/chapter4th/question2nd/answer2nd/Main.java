package com.siwuxie095.forme.algorithm.chapter4th.question2nd.answer2nd;

/**
 * 矩阵的最小路径和
 *
 * 题目：
 * 给定一个矩阵 m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有数字
 * 累加起来就是路径和，返回所有的路径中最小的路径和。
 *
 * 举例，一个矩阵如下：
 * 1    3   5   9
 * 8    1   3   4
 * 5    0   6   1
 * 8    8   4   0
 * 路径 1、3、1、0、6、1、0 是所有路径中路径和最小的，所以返回 12。
 *
 * 解答：
 * 动态规划经过空间压缩后的方法。这道题的经典动态规划方法在经过空间压缩之后，时间复杂度依然
 * 是 O(M*N)，但是额外空间复杂度可以从 O(N*N) 减小至 O(min{M, N})，也就是不使用大小为
 * M*N 的 dp 矩阵，而仅仅使用大小为 min{M, N} 的 arr 数组。具体过程如下（以例子说明）：
 * 1、生成长度为 4 的数组 arr，初始时 arr = [0, 0, 0, 0]，已知从 (0, 0) 位置到达 m
 * 中第一行的每个位置，最小路径和就是从 (0, 0) 位置的值开始依次累加的结果，所以依次把 arr
 * 设置为 arr = [1, 4, 9, 18]，此时 arr[j] 的值代表从 (0, 0) 位置达到 (0, j) 位置
 * 的最小路径和。
 * 2、步骤 1 中 arr[j] 的值代表从 (0, 0) 位置达到 (0, j) 位置的最小路径和，在这一步中
 * 想把 arr[j] 的值更新成从 (0, 0) 位置达到 (1, j) 位置的最小路径和。首先来看 arr[0]，
 * 更新之前 arr[0] 的值代表 (0, 0) 到达 (0, 0) 位置的最小路径和（dp[0][0]），如果想把
 * arr[0] 更新成从 (0, 0) 位置达到 (1, 0) 位置的最小路径和（dp[1][0]），令 arr[0] =
 * arr[0] + m[1][0] = 9 即可。然后来看 arr[1]，更新之前 arr[1] 的值代表 (0, 0) 位置
 * 到达 (0, 1) 位置的最小路径和（dp[0][1]），更新之后想让 arr[1] 代表 (0, 0) 位置到达
 * (1, 1) 位置的最小路径和（dp[1][1]）。根据动态规划的求解过程，到达 (1, 1) 位置有两种选
 * 择，一种是从 (1, 0) 位置到达 (1, 1) 位置（dp[1][0] + m[1][1]），另一种是从 (0, 1)
 * 位置达到 (1, 1) 位置（dp[0][1] + m[1][1]），应该选择路径和最小的那个。此时，arr[0]
 * 的值已经更新成 dp[1][0]，arr[1] 目前还没有更新，所以，arr[1] 还是 dp[0][1]，故：
 * arr[1] = min{arr[0], arr[1]} + m[1][1] = 5。更新之后，arr[1] 的值变为 dp[1][1]
 * 的值。同理，arr[2] = min{arr[1], arr[2]} + m[1][2] ...
 * 最终 arr 可以更新成 [9, 5, 8, 12]。
 * 3、重复步骤 2 的更新过程，一直到 arr 彻底变成 dp 矩阵的最后一行。整个过程其实就是不断滚
 * 动更新 arr 数组，让 arr 依次变成 dp 矩阵每一行的值，最终变成 dp 矩阵最后一行的值。
 *
 * 本题的例子是矩阵 m 的行数等于列数，如果给定的矩阵列数小于行数（N < M），依然可以用上面的
 * 方法令 arr 更新成 dp 矩阵每一行的值。但如果给定的矩阵行数小于列数（M < N），那么就生成
 * 长度为 M 的 arr，然后令 arr 更新成 dp 矩阵每一列的值，从左向右滚动过去。以本例来说，如
 * 果按列来更新，arr 首先更新成 [1, 9, 14, 22]，然后向右滚动更新成 [4, 5, 5, 13]，继续
 * 向右滚动更新成 [9, 8, 11, 15]，最后是 [18, 12, 12, 12]。总之，是根据给定矩阵行和列
 * 的大小关系决定滚动的方式，始终生成最小长度（min{M, N}）的 arr 数组。
 *
 * 扩展：
 * 本题压缩空间的方法几乎可以应用到所有需要二维动态规划表的题目中，通过一个数组滚动更新的方式
 * 无疑节省了大量的空间。没有优化之前，取得某个位置动态规划值的过程是在矩阵中进行两次寻址，优
 * 化后，这一过程只需要一次寻址，程序的常数时间也得到了一定的加速。但是空间压缩的方法是有局限
 * 性的，本题如果改成 "打印具有最小路径和的路径"，那么就不能使用空间压缩的方法。如果类似本题
 * 这种需要二维表的动态规划题目，最终目的是想求最优解的具体路径，往往需要完整的动态规划表，但
 * 如果只是想求最优解但值，则可以使用空间压缩的方法。因为空间压缩的方法是滚动更新的，会覆盖之
 * 前求解的值，让求解轨迹变得不可回溯。
 *
 * @author Jiajing Li
 * @date 2019-04-01 22:31:51
 */
public class Main {

    public static void main(String[] args) {
        int[][] m = new int[][]{
                {1, 3, 5, 9},
                {8, 1, 3, 4},
                {5, 0, 6, 1},
                {8, 8, 4, 0}
        };
        System.out.println("矩阵的最小路径和 = " + Path.minPathSum(m));
    }

}
