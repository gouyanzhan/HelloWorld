package com.siwuxie095.forme.algorithm.chapter4th.question14th.answer1st;

/**
 * 排成一条线的纸牌博弈问题
 *
 * 题目：
 * 给定一个整型数组 arr，代表数值不同的纸牌排成一条线。玩家 A 和玩家 B 依次拿走每张纸牌，
 * 规定玩家 A 先拿，玩家 B 后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家 A 和玩家
 * B 都绝顶聪明。请返回最后获胜者的分数。
 *
 * 比如：
 * arr = [1, 2, 100, 4]。
 * 开始时玩家 A 只能拿走 1 或 4。如果玩家 A 拿走 1，则排列变为 [2, 100, 4]，接下来玩
 * 家 B 可以拿走 2 或 4，然后继续轮到玩家 A。如果玩家 A 拿走 4，则排列变为 [1, 2, 100]，
 * 接下来玩家 B 可以拿走 1 或 100，然后继续轮到玩家 A。玩家 A 作为绝顶聪明的人不会先拿
 * 4，因为拿 4 之后，玩家 B 将拿走 100。所以玩家 A 会先拿 1，让排列变为 [2, 100, 4]，
 * 接下来玩家 B 不管怎么选，100 都会被玩家 A 拿走。玩家 A 会获胜，分数为 101。所以返回
 * 101。
 * arr = [1, 100, 2]。
 * 开始时玩家 A 不管拿 1 还是 2，玩家 B 作为绝顶聪明的人，都会把 100 拿走。玩家 B 会获
 * 胜，分数为 100。所以返回 100。
 *
 * 解答：
 * 暴力递归的方法。定义递归函数 f(i, j)，表示如果 arr[i..j] 这个排列上的纸牌被绝顶聪明
 * 的人先拿，最终能获得什么分数。定义递归函数 s(i, j)，表示如果 arr[i..j] 这个排列上的
 * 纸牌被绝顶聪明的人后拿，最终能获得什么分数。
 * 首先来分析 f(i, j)，具体过程如下：
 * 1、如果 i == j。即 arr[i..j] 上只剩下一张纸牌，当然会被先拿纸牌的人拿走，所以返回
 * arr[i]。
 * 2、如果 i != j。当前拿纸牌的人有两种选择，要么拿走 arr[i]，要么拿走 arr[j]。如果拿
 * 走 arr[i]，那么排列将剩下 arr[i+1..j]。对当前玩家来说，面对 arr[i+1..j] 排列的纸
 * 牌，他成了后拿的人，所以后续他能获得的分数为 s(i+1, j)。如果拿走 arr[j]，那么排列将
 * 剩下 arr[i..j-1]。对当前玩家来说，面对 arr[i..j-1] 排列的纸牌，他成了后拿的人，所
 * 以后续他能获得的分数为 s(i, j-1)。作为绝顶聪明的人，必然会在两种决策中选最优的。所以
 * 返回 max{arr[i] + s(i + 1, j), arr[j] + s(i, j - 1)}。
 *
 * 然后来分析 s(i, j)，具体过程如下：
 * 1、如果 i == j，即 arr[i..j] 上只剩下一张纸牌。作为后拿纸牌的人必然什么也得不到，返
 * 回 0。
 * 2、如果 i != j。根据函数 s 的定义，玩家的对手会先拿纸牌。对手要么拿走 arr[i]，要么拿
 * 走 arr[j]。如果对手拿走 arr[i]，那么排列将剩下 arr[i+1..j]，然后轮到玩家先拿。如果
 * 对手拿走 arr[j]，那么排列将剩下 arr[i..j-1]，然后轮到玩家先拿。对手也是绝顶聪明的人，
 * 所以必然会把最差的情况留给玩家。所以返回 min{f(i+1, j), f(i, j-1)}。
 * 具体代码请参看 win1() 方法。
 *
 *
 * 暴力递归的方法中，递归函数一共会有 N 层，并且是 f 和 s 交替出现的。f(i, j) 会有 s
 * (i+1, j) 和 s(i, j-1) 两个递归分支，s(i, j) 也会有 f(i+1, j) 和 f(i, j-1) 两
 * 个递归分支。所以整体时间复杂度为 O(2^N)，额外空间复杂度为 O(N)。下面介绍动态规划的方
 * 法，如果 arr 长度为 N，生成两个大小为 N * N 的矩阵 f 和 s，f[i][j] 表示函数 f(i, j)
 * 的返回值，s[i][j] 表示函数 s(i, j) 的返回值。规定一下两个矩阵的计算方向即可。具体代
 * 码请参看 win2() 方法。
 *
 * 如上的 win2() 方法中，矩阵 f 和 s 一共有 O(N^2) 个位置，每个位置计算的过程都是 O(1)
 * 的比较过程，所以 win2() 方法的时间复杂度为 O(N^2)，额外空间复杂度为 O(N^2)。
 *
 *
 * PS：f 即 first，s 即 second。
 *
 * @author Jiajing Li
 * @date 2019-04-08 12:25:40
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = new int[] {1, 2, 100, 4};
        System.out.println(Win.win1(arr));
        System.out.println(Win.win2(arr));

        System.out.println();
        arr = new int[] {1, 100, 2};
        System.out.println(Win.win1(arr));
        System.out.println(Win.win2(arr));
    }

}
