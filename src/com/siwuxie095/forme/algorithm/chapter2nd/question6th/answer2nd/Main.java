package com.siwuxie095.forme.algorithm.chapter2nd.question6th.answer2nd;

/**
 * 环形单链表的约瑟夫问题
 *
 * 题目：
 * 据说著名犹太历史学家 Josephus 有过以下故事：在罗马人占领桥塔帕特后，39 个
 * 犹太人与 Josephus 即他的朋友躲到一个洞中，39 个犹太人决定宁愿死也不要被敌
 * 人抓到，于是决定了一个自杀方式，41 个人排成一个圆圈，由第 1 个人开始报数，
 * 报数到 3 的人就自杀，然后再由下一个人重新报 1，报数到 3 的人再自杀，这样依
 * 次下去，直到剩下最后一个人时，那个人就可以自由选择自己的命运。
 * 这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。
 *
 * 输入：一个环形单向链表的头节点 head 和报数的值 m。
 * 输出：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。
 *
 * 这里更加进阶：如果链表节点数为 N，想在时间复杂度为 O(N) 时完成原问题的要求，
 * 该怎么实现呢？
 *
 * 解答：
 * 普通解法之所以花费时间多，是因为一开始不知道哪一个节点最后会活下来。所以依
 * 靠不断删除来淘汰节点，当只剩下一个节点的时候，才知道是这个节点。
 * 如果不通过一直删除的方式，就能直接确定最后活下来的节点是哪个节点，这就是进
 * 阶解法的实质。
 * 如：
 * 环形链表：1 -> 2 ->3 -> 4 -> 5 -> 1，这个链表的节点数 n = 5，m = 3。
 * 通过普通解法（不断删除的方式）可以知道最后节点 4 会活下来，但是可以使用进
 * 阶解法，也就是根据 n 和 m 的值，直接算出节点 4 最终会活下来，接下来找到
 * 节点 4 即可。
 * 那到底是怎么算出来的？可做如下定义：从环形链表的头节点开始编号，头节点编号
 * 为 1，下一个节点编号为 2 ... 最后一个节点编号为 n。然后考虑如下问题：
 * 最后只剩下一个节点，这个幸存节点在只由自己组成的环中编号为 1，记为 Num(1) = 1；
 * 在由两个节点组成的环中，这个幸存节点的编号是多少呢？假设编号是 Num(2)；
 * ...
 * 在由 i-1 个节点组成的环中，这个幸存节点的编号是多少呢？假设编号是 Num(i-1)；
 * 在由 i 个节点组成的环中，这个幸存节点的编号是多少呢？假设编号是 Num(i)；
 *
 * 已知 Num(1) = 1，如果再确定 Num(i-1) 和 Num(i) 到底是什么关系，就可以
 * 通过递归过程求出 Num(n)。Num(i-1) 与 Num(i) 的关系分析如下：
 * 1、假设圈中现在有 i 个节点，从头节点开始报数，报 1 的是编号 1 的节点，报 2
 * 的是编号 2 的节点，假设报 A 的是编号 B 的节点，则 A 和 B 有如下对应关系：
 * A    1 2 ... i      i+1 i+2 ... 2i      2i+1 2i+2 ... 3i
 * B    1 2 ... i      1   2   ... i       1    2    ... i
 *即 报数 A 和 编号 B 之间的关系是：B = (A - 1) % i + 1
 * 2、如果编号为 s 的节点被删除，环的节点数从 i 变成了 i-1，那么在原来大小为 i
 * 的环中，每个节点的编号变化如下：
 * X    ... s-2     s-1     s                       s+1     s+2 ...
 * Y    ... i-2     i-1     *（无编号，因为被删除了）   1       2   ...
 * （X 表示环大小为 i 的每个节点编号，Y 表示删掉编号 s 的节点后，环大小为 i-1
 * 的每个节点编号）
 * 新的环只有 i-1 个节点，因为有一个节点已经删掉。编号为 s 的节点往后，编号为
 * s+1、s+2、s+3 的节点就变成了新环中的编号为 1、2、3 的节点；编号为 s 的节点
 * 的前一个节点，也就是编号 s-1 的节点，就成了新环中的最后一个节点，也就是编号为
 * i-1 的节点。
 * 假设环大小为 i 的节点编号记为 old，环大小为 i-1 的每个节点编号记为 new，则
 * old 与 new 的关系的数学表达式为 old = (new + s - 1) % i + 1。
 * 3、因为每次都是报数到 m 的节点被杀，所以根据步骤 1 的表达式，A = m，被杀的
 * 节点编号为 (m - 1) % i + 1，也即 s，带入到步骤 2 的表达式中，经过化简，可
 * 以得到 old = (new + m - 1) % i + 1。所以就得到了 Num(i-1) = new 和 Num(i)
 * = old 的关系，且这个关系只和 m 与 i 的值有关。
 *
 * 整个进阶解法的过程总结为：
 * 1、遍历链表，求链表的节点个数记为 n，时间复杂度为 O(N)。
 * 2、根据 n 和 m 的值，还有上面的 Num(i-1) 和 Num(i) 的关系，递归求生存节点的
 * 编号；这一步的具体过程可以看 getLive() 方法，这个方法是单决策的递归函数，且递
 * 归为 N 层，所以时间复杂度为 O(N)。
 * 3、最后，根据生存节点的编号，遍历链表找到该节点，时间复杂度为 O(N)。
 * 4、整个过程结束，总的时间复杂度为 O(N)。
 *
 * @author Jiajing Li
 * @date 2019-02-17 21:31:09
 */
public class Main {

    public static void main(String[] args) {
        Node head = initNode();
        Node finalNode = Josephus.josephusKill(head, 3);
        System.out.println("最后剩下的那个节点（且自循环）：" + finalNode.value + " - " + finalNode.next.value);
    }

    private static Node initNode() {
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        Node node3 = new Node(3);
        Node node4 = new Node(4);
        Node node5 = new Node(5);

        node1.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node5;
        node5.next = node1;

        return node1;
    }

}
