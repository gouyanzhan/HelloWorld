package com.siwuxie095.forme.algorithm.chapter5th.question15th.answer1st;


/**
 * 公式字符串求值
 *
 * 题目：
 * 给定一个字符串 str，str 表示一个公式，公式里可能有整数、加减乘除符号和左右括号，
 * 返回公式的计算结果。
 *
 * 比如：
 * str = "48*((70-65)-43)+8*1"，返回 -1816。
 * str = "3+1*4"，返回 7。
 * str = "3+(1*4)"，返回 7。
 *
 * 说明：
 * 1、可以认为给定的字符串一定是正确的公式，即不需要对 str 做公式有效性检查。
 * 2、如果是负数，就需要用括号括起来，比如 "4*(-3)"。但如果负数作为公式但开头或括
 * 号部分的开头，则可以没有括号，比如 "-3*4" 和 "(-3*4)" 都是合法的。
 * 3、不用考虑计算过程中会发生溢出的情况。
 *
 * 解答：
 * 本题的实现方式很多，这里提供一种以供参考。假设 value() 方法是一个递归过程，具体
 * 解释如下：
 * 从左到右遍历 str，开始遍历或者遇到字符 '(' 时，就进行递归过程。当发现 str 遍历
 * 完，或者遇到字符 ')' 时，递归过程就结束。比如 "3*(4+5)+7"，一开始遍历就进入递
 * 归过程 value(str, 0)，在递归过程 value(str, 0) 中继续遍历 str，当遇到字符
 * '(' 时，递归过程 value(str, 0) 又重复调用递归过程 value(str, 3)。然后在递
 * 归过程 value(str, 3) 中继续遍历 str，当遇到字符 ')' 时，递归过程 value(str, 3)
 * 结束，并向递归过程 value(str, 0) 返回两个结果，第一结果是 value(str, 3) 遍
 * 历过的公式字符子串的结果，即 "4+5" == 9，第二个结果是 value(str, 3) 遍历到的
 * 位置，即字符 ')' 的位置 == 6。递归过程 value(str, 0) 收到这两个结果后，既可知
 * 道交给 value(str, 3) 过程处理的字符串结果是多少 （"(4+5)" 的结果是 9），又可
 * 知道自己下一步该从什么位置继续遍历（该从位置 6 的下一个位置 即位置 7 继续遍历）。
 * 总之，value() 方法的第二个参数代表递归过程是从什么位置开始的，返回的结果是一个长
 * 度为 2 的数组，记为 res。res[0] 表示这个递归过程计算的结果，res[1] 表示这个递
 * 归过程遍历到 str 的什么位置。
 * 既然在递归过程中国呢遇到 '(' 就交给下一层的递归过程处理，自己只用接收 '(' 和 ')'
 * 之间的公式字符子串的结果，所以对所有的递归过程来说，可以看作计算的公式都是不含有
 * '(' 和 ')' 字符的。比如，对递归过程 value(str, 0) 来说，实际上计算的公式是
 * "3*9+7"，"(4+5)" 的部分交给递归过程 value(str, 3) 处理，拿到结果 9 之后，再
 * 从字符 '+' 继续。所以，只要想清楚如何计算一个不含有 '(' 和 ')' 的公式字符串，整
 * 个实现就完成了。
 *
 * @author Jiajing Li
 * @date 2019-04-25 13:50:36
 */
public class Main {

    public static void main(String[] args) {
        System.out.println(Value.getValue("48*((70-65)-43)+8*1"));
        System.out.println(Value.getValue("3+1*4"));
        System.out.println(Value.getValue("3+(1*4)"));
    }

}
