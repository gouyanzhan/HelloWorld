package com.siwuxie095.forme.algorithm.chapter5th.question13th.answer1st;

/**
 * 添加最少字符使字符串整体都是回文字符串
 *
 * 题目：
 * 给定一个字符串 str，如果可以在 str 的任意位置添加字符，请返回在添加字符最少的情况下，
 * 让 str 整体都是回文字符串的一种结果。
 *
 * 比如：
 * str = "ABA"。str 本身就是回文串，不需要添加字符，所以返回 "ABA"。
 * str = "AB"，可以在 'A' 之前添加 'B'，使 str 整体都是回文串，故可以返回 "BAB"。
 * 也可以在 'B' 之后添加 'A'，使 str 整体都是回文串，故也可以返回 "ABA"。总之，只要
 * 添加的字符数最少，只返回其中一种结果即可。
 *
 * 进阶题目：
 * 给定一个字符串 str，再给定 str 的最长回文子序列字符串 lps，请返回在添加字符最少的情
 * 况下，让 str 整体都是回文字符串的一种结果。进阶问题比原问题多了一个参数，请做到时间复
 * 杂度比原问题的实现低。（lps 即 longest palindrome subsequence）
 *
 * 比如：
 * str = "A1B21C"，lps = "121"，返回 "AC1B2B1CA" 或 "CA1B2B1AC"。总之，只要是
 * 添加的字符数最少，只返回其中一种结果即可。
 *
 * 解答：
 * 原问题。在求解原问题之前，先来解决下面这个问题，如果可以在 str 的任意位置添加字符，最
 * 少需要添加几个字符可以让 str 整体都是回文字符串。这个问题可以用动态规划的方法求解。如
 * 果 str 的长度为 N，动态规划表是一个 N*N 的矩阵记为 dp[][]。dp[i][j] 值的含义代表
 * 子串 str[i..j] 最少添加几个字符可以使 str[i..j] 整体都是回文串。那么，如果求 dp[i]
 * [j] 的值呢？有如下三种情况：
 * （1）如果字符串 str[i..j] 只有一个字符，此时 dp[i][j] = 0，这是很明显的，如果 str
 * [i..j] 只有一个字符，那么 str[i..j] 已经是回文串了，自然不必添加任何字符。
 * （2）如果字符串 str[i..j] 只有两个字符。如果两个字符相等，那么 dp[i][j] = 0。比如，
 * 如果 str[i..j] = "AA"，两字符相等，说明 str[i..j] 已经是回文串，自然不必添加任何
 * 字符。如果两个字符不相等，那么 dp[i][j] = 1。比如，如果 str[i..j] = "AB"，只用添
 * 加一个字符就可以令 str[i..j] 变成回文串，所以 dp[i][j] = 1。
 * （3）如果字符串 str[i..j] 多于两个字符。如果 str[i] == str[j]，那么 dp[i][j] =
 * dp[i+1][j-1]。比如，如果 str[i..j] 为 "A124521A"，str[i..j] 需要添加的字符数与
 * str[i+1..j-1]（即 "124521"）需要添加的字符数是相等的，因为只要能把 "124521" 整体
 * 变成回文串，然后再左右两头加上 'A'，就是 str[i..j] 整体变成回文串的结果。如果 str[i]
 * != str[j]，要让 str[i..j] 整体变成回文串有两种方法，一种方法是让 str[i..j-1] 先变
 * 成回文串，然后在左边加上字符 str[j]，就是 str[i..j] 整体变成回文串的结果。另一种方法是
 * 让 str[i+1..j] 先变成回文串，然后在右边加上字符 str[i]，就是 str[i..j] 整体变成回文
 * 串的结果。两种方法中哪个代价小就选择哪个，即 dp[i][j] = min{dp[i][j-1]，dp[i+1][j]}
 * + 1。
 * 既然 dp[i][j] 的值代表子串 str[i..j] 最少添加几个字符可以使 str[i..j] 整体都是回文
 * 串，所以根据上面的方法求出整个 dp 矩阵后，就得到了 str 中任何一个子串添加几个字符后可以
 * 变成回文串。具体代码请参看 getDP() 方法。
 *
 *
 * 下面介绍如何根据 dp 矩阵，求在添加字符最少的情况下，让 str 整体都是回文字符串的一种结果。
 * 首先，dp[0][N-1] 的值代表整个字符串最少需要添加几个字符，所以，如果最后的结果记为字符串
 * res，res 的长度 = dp[0][N-1] + str 的长度，然后依次设置 res 左右两头的字符。具体的
 * 过程如下：
 * （1）如果 str[i..j] 中 str[i] == str[j]，那么 str[i..j] 变成回文串的最终结果 =
 * str[i] + str[i+1..j-1] 变成回文串的结果 + str[j]，此时 res 左右两头的字符为 str[i]
 * （也是 str[j]），然后继续根据 str[i+1..j-1] 和矩阵 dp 来设置 res 的中间部分。
 * （2）如果 str[i..j] 中 str[i] != str[j]，看 dp[i][j-1] 和 dp[i+1][j] 哪个小。
 * 如果 dp[i][j-1] 更小，那么 str[i..j] 变成回文串的最终结果 = str[j] + str[i..j-1]
 * 变成回文串的结果 + str[j]，所以此时 res 左右两头的字符为 str[j]，然后继续根据 str[i..j-1]
 * 和矩阵 dp 来设置 res 的中间部分。而如果 dp[i+1][j] 更小，那么 str[i..j] 变成回文串
 * 的最终结果 = str[i] + str[i+1..j] 变成回文串的结果 + str[i]，所以此时 res 左右两
 * 头的字符为 str[i]，然后继续根据 str[i+1..j] 和矩阵 dp 来设置 res 的中间部分。如果一
 * 样大，任选一种设置方式都可以得出最终结果。
 * （3）如果发现 res 所有的位置都已设置完毕，过程结束。
 *
 * 求解 dp 矩阵的时间复杂度为 O(N^2)，根据 str 和 dp 矩阵求解最终结果的过程为 O(N)，所以
 * 原问题解法中总的时间复杂度为 O(N^2)。
 *
 * @author Jiajing Li
 * @date 2019-04-22 21:53:02
 */
public class Main {

    public static void main(String[] args) {
        System.out.println(Palindrome.getPalindrome("AB"));
        System.out.println(Palindrome.getPalindrome("ABC"));
        System.out.println(Palindrome.getPalindrome("ABCD"));
    }

}
