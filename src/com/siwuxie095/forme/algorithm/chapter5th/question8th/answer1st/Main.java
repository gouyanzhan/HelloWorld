package com.siwuxie095.forme.algorithm.chapter5th.question8th.answer1st;

/**
 * 判断字符数组中是否所有的字符都只出现过一次
 *
 * 题目：
 * 给定一个字符类型数组 charArr[]，判断 charArr 中是否所有的字符都只出现过一次，请根据
 * 以下不同的两种要求实现两个函数。
 *
 * 比如：
 * charArr = ['a', 'b', 'c']，返回 true。
 * charArr = ['1', '2', '1']，返回 false。
 *
 * 要求：
 * 1、实现时间复杂度为 O(N) 的方法。
 * 2、在保证额外空间复杂度为 O(1) 的前提下，请实现时间复杂度尽量低的方法。
 *
 * 解答：
 * 要求 1。遍历一遍 charArr，用 map 记录每种字符的出现情况，这样就可以在遍历时发现字符
 * 重复出现的情况，map 可以用长度固定的数组实现，也可以用哈希表实现。
 * 具体代码请参看 isUnique1() 方法。
 *
 * 要求 2。整体思路是先将 charArr 排序，排序后相同的字符就放在一起，然后判断有没有重复
 * 字符就会非常容易，所以问题的关键是选择什么样的排序算法。因为必须保证额外空间复杂度为
 * O(1)，所以本题是考查对经典排序算法在额外空间复杂度方面的理解程度。首先任何时间复杂度
 * 为 O(N) 的排序算法做不到额外空间复杂度为 O(1)，因为这些排序算法不是基于比较的排序算
 * 法，所以有多少个数都得 "装下"，然后按照一定顺序 "倒出" 来完成排序。具体细节可以查阅
 * 相关图书中有关桶排序、基数排序、计数排序等内容。然后看时间复杂度为 O(N*logN) 的排序
 * 算法，常见的有归并排序、快速排序、希尔排序和堆排序。归并排序首先被排除，因为归并排序中
 * 有两个小组合并成一个大组的过程，这个需要辅助数组才能完成，尽管归并排序可以使用手摇算法
 * 将额外空间复杂度降至 O(1)，但这样最差情况下但时间复杂度会因此上升至 O(N^2)。快速排序
 * 也被排除，因为无论选择递归实现还是非递归实现，快速排序的额外空间复杂度最低为 O(N*logN)，
 * 不能达到 O(1) 的程度。希尔排序同样被排除，因为希尔排序的时间复杂度并不固定，成败完全
 * 在于步长的选择，如果选择不当，时间复杂度会变成 O(N^2)。这四种经典排序中，只有堆排序
 * 可以做到额外空间复杂度为 O(1) 的情况下，时间复杂度还能稳定地保持在 O(N*logN)。那么
 * 堆排序就是答案。
 * 但遗憾的是，虽然堆排序的确是答案，但大部分资料提供但堆排序但实现却是基于递归函数实现的。
 * 而递归函数需要使用函数栈空间，这样堆排序的额外空间复杂度就增加至 O(logN)。所以需要用
 * 非递归的方式实现堆排序。
 *
 * @author Jiajing Li
 * @date 2019-04-15 20:38:44
 */
public class Main {

    public static void main(String[] args) {
        System.out.println(Unique.isUnique1("abc".toCharArray()));
        System.out.println(Unique.isUnique1("121".toCharArray()));
        System.out.println();
        System.out.println(Unique.isUnique2("abc".toCharArray()));
        System.out.println(Unique.isUnique2("121".toCharArray()));
    }

}
