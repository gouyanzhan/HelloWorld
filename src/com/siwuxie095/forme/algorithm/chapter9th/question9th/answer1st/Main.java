package com.siwuxie095.forme.algorithm.chapter9th.question9th.answer1st;

/**
 * 最大的 leftMax 与 rightMax 之差的绝对值
 *
 * 题目：
 * 给定一个长度为 N（N > 1）的整型数组 arr，可以划分成左右两个部分，左部分为 arr[0..K]，右部分为
 * arr[K+1..N-1]，K 可以取值的范围是 [0, N-2]。求这么多划分方案中，左部分中的最大值减去右部分最
 * 大值的绝对值中，最大是多少？
 * 例如：[2, 7, 3, 1, 1]，当左部分为 [2, 7]，右部分为 [3, 1, 1] 时，左部分中最大值减去右部分最
 * 大值的绝对值为 4。当左部分为 [2, 7, 3]，右部分为 [1, 1] 时，左部分最大值减去右部分最大值的绝对
 * 值为 6。还有很多划分方案，但最终返回 6。
 *
 * 解答：
 * 方法一：时间复杂度为 O(N^2)，额外空间复杂度为 O(1)。这是最笨的方法，在数组的每个位置 i 都做一次
 * 这种划分，找到 arr[0..i] 的最大值 maxLeft，找到 arr[i+1..N-1] 的最大值 maxRight，然后计算
 * 两个值相减的绝对值。每次划分都这样求一次，自然可以得到最大的相减的绝对值。具体代码请参看 maxABS1()
 * 方法。
 * 方法二：时间复杂度为 O(N)，额外空间复杂度为 O(N)。使用预处理数组的方法，先从左到右遍历一次生成
 * lArr，lArr[i] 表示 arr[0..i] 中的最大值。再从右到左遍历一次生成 rArr，rArr[i] 表示 arr[i..N-1]
 * 中的最大值。最后一次遍历看哪种划分的情况下可以得到两部分最大的相减的绝对值，因为预处理数组已经保存
 * 了所有划分的 max 值，所以过程得到了加速。具体代码请参看 maxABS2() 方法。
 * 方法三：最优解，时间复杂度为 O(N)，额外空间复杂度为 O(1)。先求整个 arr 的最大值 max，因为 max
 * 是全局最大值，所以不管怎么划分，max 要么会成为左部分的最大值，要么会成为右部分的最大值。如果 max
 * 作为左部分的最大值，接下来只要让右部分的最大值尽量小就可以。右部分的最大值怎么尽量小呢？右部分只含
 * 有 arr[N-1] 的时候就是尽量小的时候。同理，如果 max 作为右部分的最大值，只要让左部分的最大值尽量
 * 小就可以，左部分只含有 arr[0] 的时候就是尽量小的时候。所以整个求解过程会变得异常简单。具体代码请
 * 参看 maxABS3() 方法。
 *
 * @author Jiajing Li
 * @date 2019-06-23 21:50:34
 */
public class Main {

    public static void main(String[] args) {
        int[] arr = {10, 9, 11, 5, 4, 0, 1};
        System.out.println(Absolute.maxABS1(arr));
        System.out.println(Absolute.maxABS2(arr));
        System.out.println(Absolute.maxABS3(arr));
    }

}
