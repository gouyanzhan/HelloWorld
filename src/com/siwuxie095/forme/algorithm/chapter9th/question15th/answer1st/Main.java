package com.siwuxie095.forme.algorithm.chapter9th.question15th.answer1st;

/**
 * 一种字符串和数字的对应关系
 *
 * 题目：
 * 一个 char 类型的数组 chArr，其中所有的字符都不同。
 *
 * 比如，chArr = ['A', 'B', 'C', ... 'Z']，则字符串与整数的对应关系如下：
 * A，B，... Z，AA，AB，...AZ，BA，BB，...ZZ，AAA，...ZZZ， AAAA ...
 * 1，2，...26，27，28，....52，53，54，...702，703，...18278，182793 ...
 *
 * 比如，chArr = ['A', 'B', 'C']，则字符串与整数的对应关系如下：
 * A，B，C，AA，AB，...CC，AAA，...CCC，AAAA ...
 * 1，2，3，4，5，...12，13，...39，40 ...
 *
 * 给定一个数组 chArr，实现根据对应关系完成字符串与整数相互转换的两个函数。
 *
 * 解答：
 * 面试者在分析这道题时，往往会将字符串与数字的对应关系与 K 进制数联系起来，K 指 chArr 的长度，比如，第一个例子中
 * chArr 的长度为 26。最终会发现用 K 进制数是不能实现的。下面就解释以下本题的对应关系与 K 进制数不同的地方。
 * K 进制数是每一个位置上的值只能在 [0, K-1] 之间取值。例如，十进制数的 72，高位为 7，低位为 2。十进制数的 72
 * 转换成三进制数的表达为 2200。也就是 72 = 27*2 + 9*2 + 3*0 + 1*0。但是本题描述的对应方式却不是这样，这里暂
 * 时把题目描述的对应方式叫做 K 伪进制数，K 伪进制数是每一个位置上的值只能在 [1, K] 之间取值。以 chArr = ['A',
 * 'B', 'C'] 来举例，即 3 伪进制数。如果把十进制数的 72 用这个 chArr 的 3 伪进制数表示是 "BABC"，也就是 72 =
 * 27*2 + 9*1 + 3*2 + 1*3。也就是对 K 进制数来讲，每个位（如：27、9、3、1）上的值是可以取 0 的，但如果位上的
 * 值不为 0，也在 [1, K-1] 范围上。而对 K 伪进制数来讲，每个位上的值绝对不能取 0，而是必须在 [1, K] 之间。所以
 * 用 K 进制数的思路是不能实现本题的对应关系的。
 * 下面解释以下这里提供的解法，先看从数字如何得到字符串。还是以 chArr = ['A', 'B', 'C'] 为例，以下是十进制数的
 * 72 得到表达它的字符串的过程：
 * 1、chArr 的长度为 3，所以这是一个 3 伪进制，从低位到高位依次为 1，3，9，27，81...。
 * 2、从 1 开始减，72 减 1，剩下 71：71 减去 3，剩下 68：68 减去 9，剩下 59：59 减去 27，剩下 32：32 减去
 * 81 时，发现不够减，此时就知道想要表达十进制数的 72，只需使用 3 伪进制的前 4 位，也就是 27、9、3、1，而不必扩
 * 到第 5 位的 81。换句话说，既然 K 伪进制中每个位上的值都不能为 0，就从低位到高位把每个位置上的值都先减去 1 遍，
 * 看这个数到底需要前几位。
 * 3、步骤 2 剩下的数是 32，同时前 4 位的值已经使用了 1 次，即 72 - 32 = 40 = 27*1 + 9*1 + 3*1 + 1*1 =
 * "AAAA"。接下来看剩下的 32 最多可以用几个 27 呢？最多用 1 个（32/27 = 1），再算上之前的一个 27，一共要 2 个
 * 27（B）。32%27 = 5，这表示让 32 减去尽量多的 27 而剩下的数。然后看 5 最多可以用几个 9，一个也用不了，再算上
 * 之前的一个 9，一共要 1 个 9（A）。5%9 = 5，接下来看 5 最多可以用几个 3，1 个，再算上之前的一个 3，一共要 2 个
 * 3（B）。5%3 = 2，最后看 2 最多可以用几个 1，2 个，算上之前的一个 1，一共 3 个 1（C）。所以结果是 "BABC"。
 *
 * 上文所描述的 K 伪进制虽然和 K 进制不同，但是把十进制数转换成 K 伪进制数的过程却和把十进制转换成 K 进制数的过程相似。
 * 具体来说，步骤 2 中是从低位到高位看一个数 N 最多用几个 K 伪进制的位，时间复杂度为 O(logN)（以 K 为底），步骤 3
 * 是从高位到低位反着回去看每个位上到值最多是多少，时间复杂度也是 O(logN)（以 K 为底），K 为 chArr 到长度，所以以上
 * 过程的时间复杂度为 O(logN)（以 chArr 的长度为底）。
 * 数字到字符串的过程请参看 getString() 方法。
 *
 * 接下来介绍如何通过字符串得到对应的数字。其实如果理解了 K 伪进制数的含义，算出字符串对应的数字就十分容易了。例如，chArr
 * = ['A', 'B', 'C']，字符串 "ABBA"，可以知道这个字符串的含义是 27 有 1 个，9 有 2 个，3 有 1 个，1 有 1 个，所
 * 以对应的数字为 52。
 * 字符串到数字的过程请参看 getNum() 方法。
 *
 * @author Jiajing Li
 * @date 2019-07-06 15:16:15
 */
public class Main {

    public static void main(String[] args) {
        char[] chArr = {'A', 'B', 'C'};
        // num to string
        System.out.println(Mapping.getString(chArr, 72));
        // string to num
        System.out.println(Mapping.getNum(chArr, "BABC"));
    }

}
