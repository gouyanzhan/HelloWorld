package com.siwuxie095.forme.algorithm.chapter9th.question6th.answer1st;

/**
 * 折纸问题
 *
 * 题目：
 * 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折 1 次，压出折痕后展开。此时折痕是凹下去的，即折痕凸起的方向
 * 指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕
 * 和上折痕。给定一个输入参数 N、代表纸条都从下边向上方连续对折 N 次，请从上到下打印所有折痕的方向。
 *
 * 比如：
 * N = 1 时，打印：
 * down
 * N = 2 时，打印：
 * down
 * down
 * up
 *
 * 解答：
 * 对折第 1 次产生的折痕：                下
 * 对折第 2 次产生的折痕：            上       下
 * 对折第 3 次产生的折痕：    上     下       上       下
 * 对折第 4 次产生的折痕：上   下   上   下   上   下   上   下
 *
 * 根据如上关系可以总结出：
 * （1）产生第 i+1 次折痕的过程，就是在对折 i 次产生的每一条折痕的左右两侧，依次插入上折痕和下折痕的过程。
 * （2）所有折痕的结构是一颗满二叉树，在这颗满二叉树中，头节点为下折痕，每一颗左子树的头节点为上折痕，每一
 * 颗右子树的头节点为下折痕。
 * （3）从上到下打印所有折痕方向的过程，就是二叉树的先右、再中、最后左的中序遍历。
 *
 * 纸条连续对折 n 次之后一定产生 2^(n-1) 条折痕，所以要打印所有的节点，不管用什么方法，其时间复杂度肯定
 * 都是 O(2^n)，因为解的空间本身就有这么大，但是本书提供的方法的额外空间复杂度为 O(N)，也就是这颗满二叉
 * 树的高度，额外空间主要用来维持递归函数的运行，也就是函数栈的大小。
 *
 * @author Jiajing Li
 * @date 2019-06-16 22:47:00
 */
public class Main {

    public static void main(String[] args) {
        Fold.printAllFolds(3);
    }

}
