package com.siwuxie095.forme.algorithm.chapter9th.question3rd.answer1st;

/**
 * 有关阶乘的两个问题
 *
 * 题目：
 * 给定一个非负整数 N，返回 N! 结果的末尾为 0 的数量。
 * 例如：3!=6，结果的末尾没有 0，则返回 0。5!=120，结果的末尾有 1 个 0，返回 1。
 * 1 000 000 000!，结果的末尾有 249999998 个 0，返回 249999998。
 *
 * 进阶题目：
 * 给定一个非负整数 N，如果用二进制数表达 N! 的结果，返回最低位的 1 在哪个位置上，
 * 认为最右的位置为位置 0。
 * 例如：1!=1，最低位的 1 在 0 位置上。2!=2，最低位的 1 在 1 位置上。1 000 000
 * 000!，最低位的 1 在 999999987 上。
 *
 * 解答：
 * 无论是原问题还是进阶问题，通过算出真实的阶乘结果后再处理的方法无疑是不合适的，因
 * 为阶乘的结果通常很大，非常容易溢出，而且会增加计算的复杂性。
 * 先来介绍原问题的一个普通解法。对原问题来说，N! 结果的末尾有多少个 0 的问题可以转
 * 换为 1，2，3，...，N-1，N 的序列中一共有多少个因子 5。这是因为 1*2*3*...*N 的
 * 过程中，因子 2 的数目比因子 5 的数目多，所以不管有多少个因子 5，都有足够的因子 2
 * 与其相乘得到 10。所以只要找出 1～N 所有的数中，一共含有多少个因子 5 就可以。具体
 * 代码请参看 zeroNum1() 方法。
 *
 * 以上方法的效率并不高，对每一个数 i 来说，处理的代价是 logi（以 5 为底），一共有
 * O(N) 个数。所以时间复杂度为 O(N*logN)。
 * 现在介绍原问题的最优解。把 1～N 的数列出来。1，2，3，4，5，6，7，8，9，10...，
 * 15...，20...，25...，30...，     ...     100...， 125...
 * 仔细观察一下上面的数就会发现：
 * 若每 5 个含有 0 个因子 5 的数（1，2，3，4，5）组成一组，这一组中的第 5 个数就含
 * 有 5^1 的因子（5）。若每 5 个含有 1 个因子 5 的数（5，10，15，20，25）组成一组，
 * 这一组中的第 5 个组就含有 5^2 的因子（25）。若每 5 个含有 2 个因子 5 的数（25，
 * 50，75，100，125）组成一组，这一组中的第 5 个数就含有 5^3 的因子（125）。若每 5
 * 个含有 i 个因子 5 的数组成一组，这一组中的第 5 个数就含有 5^(i+1) 的因子......
 * 所以，如果把 N! 的结果中因子 5 的总个数记为 Z，就可以得到如下关系：
 * Z = N/5 + N/(5^2) + N/(5^3) + ... + N/(5^i) （i 一直增长，直到 5^i > N）。
 * 用上文的例子来理解就是，1～N 中有 N/5 个数，这每个数都能贡献一个 5；然后 1～N 中
 * 有 N/(5^2) 个数，这每个数又都能贡献一个 5......。具体代码请参看 zeroNum2() 方
 * 法。
 * 可以看到，如果一共有 N 个数，最优解的时间复杂度为 O(logN)，以 5 为底。
 *
 * 进阶问题。这里提供两种方法，先来介绍解法一。与原问题的解法类似，最低位的 1 在哪个位
 * 置上，完全取决于 1～N 的数中因子 2 有多少个，因为只要出现一个因子 2，最低位的 1 就
 * 会向左移一位。所以，如果把 N! 的结果中因子 2 的总个数记为 Z，就可以得到如下关系 Z
 * = N/2 + N/4 + N/8 + ... + N/(2^i)（i 一直增长，直到 2^i > N）。具体代码请参
 * 看 rightOne1() 方法。
 * 再来介绍解法二。如果把 N! 的结果因子中因子 2 的总个数记为 Z，把 N 的二进制数表达式
 * 中 1 的个数记为 m，还存在如下一个关系 Z=N-m，也就是可以证明 N/2 + N/4 + N/8 +
 * ... = N-m。注意，这里的 / 不是数学上的除法，而是计算科学中的除法，即结果要向下取整。
 * 首先，如果一个整数 K 正好为 2 的某次方（K=2^i），那么求和公式 K/2 + k/4 + K/8 +
 * ... = K/2 + K/4 + K/8 + ... + 1，也就是在 K=2^i 时，计算科学中的除法和数学上的
 * 除法等效。所以根据等比数列求和公式 S = (末项 * 公比 - 首项)/(公比 - 1)，可以得到
 * K/2 + K/4 + K/8 + ... = K-1。
 * 如果在 N 的二进制表达式中有 m 个 1，那么 N 可以表达为：N = K1 + K2 + K3 + ...
 * + Km，其中所有 K 都等于 2 的某次方，例如，N = 10110 时，N = 10000 + 100 + 10。
 * 于是有 N/2 + N/4 + ... = (K1+K2+K3+...+Km)/2 + (K1+K2+K3+...Km)/4 + ...
 * =K1/2 + K1/4 + K1/8 + ... + 1 + K2/2 + K2/4 + ... + 1 + ... + Km/2 + Km/4
 * + ... + 1。
 * K1，K2，...，Km 都等于 2 的某次方。所以等式右边 = K1-1 + K2-1 + K3-1 + ...
 * Km-1 = (K1+...+Km)-m = N-m。至此，Z = N-m 证明完毕。具体代码请参看 rightOne2()
 * 方法。
 *
 * @author Jiajing Li
 * @date 2019-06-15 17:02:10
 */
public class Main {

    public static void main(String[] args) {
        System.out.println(Factorial.zeroNum1(1_000_000_000));
        System.out.println(Factorial.zeroNum2(1_000_000_000));
        System.out.println(Factorial.rightOne1(1_000_000_000));
        System.out.println(Factorial.rightOne2(1_000_000_000));
    }

}
