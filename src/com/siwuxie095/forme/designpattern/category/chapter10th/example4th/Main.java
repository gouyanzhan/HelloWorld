package com.siwuxie095.forme.designpattern.category.chapter10th.example4th;

/**
 * @author Jiajing Li
 * @date 2019-11-08 14:33:07
 */
public class Main {

    /**
     * 状态模式
     *
     * 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
     *
     *
     * 定义中的第一部分：因为这个模式将状态封装成独立的类，并将动作委托
     * 到代表当前状态的对象，所以，行为会随着内部状态改变而改变。比如，
     * 糖果机在 NoCoinState 和 HasCoinState 两种不同的状态时，你投
     * 入硬币，就会得到不同的行为（糖果机接受硬币和糖果机拒绝硬币）。
     *
     * 定义中的第二部分：从客户视角看，如果说你使用的对象能够改变它的行
     * 为，那么你会觉得，这个对象实际上是从别的类实例化而来的。然而，实
     * 际上，是在使用组合通过简单引用不同的状态对象来造成类改变的假象。
     *
     *
     * 状态模式与策略模式
     *
     * 状态模式与策略模式的类图是一样的，但它们的差别在于意图。
     *
     * 以状态模式而言，是将一群行为封装在状态对象中，Context 的行为随时
     * 可委托到那些状态对象中的一个。随着时间流逝，当前状态在状态对象集合
     * 中游走改变，以反映出 Context 内部的状态，因此，Context 的行为也
     * 会跟着改变。但是 Context 的客户对于状态对象了解不多，甚至根本浑然
     * 不觉。
     *
     * 而以策略模式而言，客户通常主动指定 Context 所要组合的策略对象是哪
     * 一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对
     * 于某个 Context 对象来说，通常都只有一个最适当的策略对象。
     *
     * 一般来说，是把策略模式想成是除了继承之外的一种弹性替代方案。如果你
     * 使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难。
     * 有了策略模式，可以通过组合不同的对象来改变行为。
     *
     * 而把状态模式想成是不用在 Context 中放置许多条件判断的替代方案。通
     * 过将行为包装进状态对象中，你可以通过在 Context 内简单地改变状态对
     * 象来改变 Context 的行为。
     *
     *
     * 疑问与解答
     *
     * 问：
     * 在 GumballMachine 中，状态决定了下一个状态应该是什么。ConcreteState
     * 总是决定接下来的状态是什么吗？
     * 答：
     * 不，并非总是如此，Context 也可以决定状态转换的流向。一般来讲，当状态转换
     * 是固定的时候，就适合放在 Context 中；然而当转换是更动态的时候，通常就会
     * 放在状态类中（比如，在 GumballMachine 中，由运行时糖果的数目来决定状态
     * 要转换到 NoCoinState 还是 SoldOut）。
     * 将状态转换放到状态类中的缺点是：状态类之间产生了依赖。在 GumballMachine
     * 实现中，我们试图通过使用 Context 上的 getter 方法把依赖减到最小，而不是
     * 显式硬编码具体状态类。
     * 请注意，在做这个决策的同时，也等于是在为另一件事情做决策：当系统进化时，究
     * 竟哪个类是对修改封闭的（Context 还是状态类）。
     *
     * 问：
     * 客户会直接和状态交互吗？
     * 答：
     * 不会。状态是用在 Context 中来代表它的内部状态以及行为的，所以只有 Context
     * 才会对状态提出请求。客户不会直接改变 Context 的状态。全盘了解状态是 Context
     * 的工作，客户根本不了解，所以不会直接和状态联系。
     *
     * 问：
     * 如果我的程序中 Context 有许多实例，这些实例之间可以共享状态对象吗？
     * 答：
     * 是的，绝对可以，事实上这是很常见的做法。但唯一的前提是，你的状态对象不能持有
     * 它们自己的内部状态，否则就不能共享。
     * 想要共享状态，你需要把每个状态都指定到静态的实例变量中。如果你的状态需要利用
     * 到 Context 中的方法或者实例变量，你还必须在每个 handle() 方法内传入一个
     * Context 的引用。
     *
     * 问：
     * 使用状态模式似乎总是增加我们设计中类的数目。请看 GumballMachine 中，新版本
     * 比老版本多出了许多类。
     * 答：
     * 没错，在个别的状态类中封装状态行为，结果总是增加这个设计中类的数目。这就是为了
     * 要获取弹性而付出的代价。除非你的代码是一次性的，可以用完就扔掉（才怪），那么其
     * 实状态模式的设计是绝对值得的。其实真正重要的是你暴露给客户的类数目，而且我们有
     * 办法将这些额外的状态类全部都隐藏起来。
     * 不妨看看另一种做法：如果你有一个应用，它有很多状态，但是你决定不将这些状态封装
     * 在不同的对象中，那么你就会得到巨大的、整块的条件语句。这会让你的代码不容易维护
     * 和理解。通过使用许多对象，你可以让状态变得很干净，在以后理解和维护它们时，就可
     * 以省下很多的功夫。
     *
     *
     * 注意：状态模式中，State 既可以是接口，也可以是抽象类。如果没有共同的功能放进
     * 抽象类中，就会使用接口。而如果使用了抽象类，当你以后需要在抽象类中加入新的方法
     * 时就很容易，不需要打破具体状态的实现。
     */
    public static void main(String[] args) {
        Context context = new Context();
        context.request();
        context.request();
        context.request();
    }

}
