package com.siwuxie095.forme.designpattern.category.chapter5th.example7th;

/**
 * @author Jiajing Li
 * @date 2019-10-22 15:24:30
 */
public class Main {

    /**
     * 双重检查加锁（double-checked locking）
     *
     *
     * （3）利用 "双重检查加锁"，在 getInstance() 中减少使用同步：
     * 利用双重检查加锁，首先检查实例是否已经创建，如果尚未创建，"才" 进行同步。
     * 这样一来，只有第一次会同步，这正是想要的。
     *
     * 注意：在 1.4 及更早版本的 Java 中，许多 JVM 对于 volatile 关键字的实
     * 现会导致双重检查加锁的失效。如果不能使用 Java 5，而必须使用旧版的 Java，
     * 就请不要使用此方法实现单例模式。
     *
     * 对于修改巧克力锅炉代码所遇到的问题的适用性：
     * 由于没有性能上的考虑，所以这个方法似乎是杀鸡用牛刀了。另外这个方法还得确
     * 定使用的是 Java 5 以上的版本。
     *
     *
     * 一些问答：
     *
     * 问：
     * 单例模式只有一个类，应该是很简单的模式，但是问题似乎不少。
     * 答：
     * 确实。固然正确的实现单例模式需要一点技巧，但是当需要控制实例个数时，还是
     * 应当使用单例模式。
     *
     * 问：
     * 难道不能创建一个类，把所有的方法和变量都定义为静态的，把类直接当作一个单
     * 例？
     * 答：
     * 如果你的类自给自足，而且不依赖于复杂的初始化，那么可以这么做。但是，因为
     * 静态初始化的控制权是在 Java 手中，这么做有可能导致混乱，特别是当有许多类
     * 牵涉其中的时候，这么做常常会造成一些微妙的、不容易发现的和初始化的次序有
     * 关的 bug。除非你有绝对的必要使用 "类的单件"，否则还是建议使用 "对象的单
     * 件"，比较保险。
     *
     * 问：
     * 那么类加载器（class loader）呢？听说两个类加载器可能有机会各自创建自己
     * 的单例对象？
     * 答：
     * 是的。每个类加载器都定义了一个命名空间，如果有两个以上的类加载器，不同的
     * 类加载器可能会加载同一个类，从整个程序来看，同一个类会被加载多次。如果这
     * 样的事情发生在单例类上，就会产生多个单例对象并存的怪异现象。所以，如果你
     * 的程序有多个类加载器，又同时使用了单例模式，请小心。有一个解决办法：自行
     * 指定类加载器，并指定同一个类加载器。
     *
     * 问：
     * 类应该只做一件事，而且只做一件事。类如果能做两件事，就会被认为是不好的 OO
     * 设计。单例模式有没有违背这样的观念？
     * 答：
     * 这是 "一个类，一个责任" 的原则。单例类不止负责管理自己的实例（并提供全局
     * 访问），还在应用程序中担当角色，所以也可以被视为是两个责任。尽管如此，由
     * 类管理自己的实例的做法并不少见。这可以让整体设计更简单。更何况，许多开发
     * 人员都熟悉了单例模式这种做法。
     *
     * 问：
     * 想把单例类当成超类，设计出子类，但是遇到了问题：究竟可不可以继承单例类？
     * 答：
     * 继承单例类会遇到一个问题，就是构造器是私有的。你不能用私有构造器来扩展类。
     * 所以你必须把单件的构造器改成公开的或受保护的。但是这么一来，就不算是 "真
     * 正的" 单例了，因为别的类也可以实例化它。
     * 如果你果真把构造器的访权限改了，还有另一个问题会出现。单例的实现是利用静
     * 态变量，直接继承会导致所有的派生类共享同一个实例变量，这可能不是你想要的。
     *
     * 问：
     * 还是不太了解为何全局变量比单例模式差。
     * 答：
     * 在 Java 中，全局变量基本上就是对对象的静态引用。而单例模式的目的是：确保
     * 类只有一个实例并提供全局访问。全局变量可以提供全局访问，但是不能确保只有一
     * 个实例。全局变量也会变相鼓励开发人员，用许多全局变量指向许多小对象来造成命
     * 名空间的污染。单例模式并不鼓励这样的现象，但单例模式仍然可能被滥用。
     *
     *
     * 注意：在 Java 1.2 以及以前的版本，垃圾收集器有一个 bug，会造成单例在没有
     * 全局引用时被当作垃圾清除。即 如果一个单例对象只有本单例类引用它本身，那么
     * 该单例就会被当作垃圾清除。这造成让人疑惑的 bug，因为单例对象被清除后，下次
     * 调用 getInstance() 会产生一个全新的单例对象。对很多程序来说，一切就回到
     * 了最原始的设置（例如：网络连接被重新设置）。
     */
    public static void main(String[] args) {
        ChocolateBoiler chocolateBoiler = ChocolateBoiler.getInstance();
        chocolateBoiler.fill();
        chocolateBoiler.boil();
        chocolateBoiler.drain();
    }

}
