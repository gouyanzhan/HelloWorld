package com.siwuxie095.forme.designpattern.category.chapter13th.example1st;

/**
 * @author Jiajing Li
 * @date 2019-11-10 14:25:13
 */
public class Main {

    /**
     * 设计模式
     *
     * 模式是在某情境（context）下，针对某问题的某种解决方案。
     *
     *
     * （1）情境就是应用某个模式的情况，这应该是会不断出现的情况。
     * （2）问题就是你想在某情境下达到的目标，但也可以是某情境下的约束。
     * （3）解决方案就是你所追求的：一个通用的设计，用来解决约束、达到目标。
     *
     * 这个定义需要花时间逐步理解，下面是一个帮助记忆的方法：
     * 如果你发现自己处于某个情境下，面对着所欲达到的目标被一群约束影响着的
     * 问题，然而，你能够应用某个设计，克服这些约束并达到该目标，将你领向某
     * 个解决方案。
     *
     * 即 设计模式是用来解决经常重复发生的设计问题。
     *
     *
     * 疑问与解答：
     *
     * 问：
     * 模式的描述是否由一个问题、一个情境以及一个解决方案构成呢？
     * 答：
     * 通常在模式类目中发现的模式描述不只是这些。后面就会看到模式
     * 类目的细节：模式类目描述某个模式的意图、动机、可能应用该模
     * 式的地方、解决方案的设计以及使用后果（好的或坏的）。
     *
     * 问：
     * 稍微改变某个模式的结构以符合我的设计，这样可以吗？还是一定
     * 要遵守严格的定义？
     * 答：
     * 当然可以改变模式。像设计原则一样，模式不是法律或准则，模式
     * 只是指导方针，你可以改变模式来符合你的需要。而且真实世界的
     * 许多实例，都不符合经典的设计模式。
     * 然而，但你在改变模式的适合，最好能够在文档中注明它与经典的
     * 设计模式有何差异。这样一来，其他的开发人员就能够很快地认出
     * 你用的这个模式，并了解两者的差异。
     *
     *
     * 设计模式的定义告诉我们，问题包含了一个目标和一组约束。而只
     * 有解决方案在目标和约束之间取得平衡时，才算的上是有用的模式。
     *
     *
     * 模式与描述的配对：
     *
     * （1）装饰者模式：
     * 包装一个对象，以提供新的行为。
     *
     * （2）状态模式：
     * 封装了基于状态的行为，并使用委托在行为之间切换。
     *
     * （3）迭代器模式：
     * 在对象的集合之中游走，而不是暴露集合的实现。
     *
     * （4）外观模式：
     * 简化一群类的接口。
     *
     * （5）策略模式：
     * 封装可以互换的行为，并使用委托来决定要使用哪一个。
     *
     * （6）代理模式：
     * 包装对象，以控制对此对象的访问。
     *
     * （7）工厂方法模式：
     * 由子类决定要创建的具体类是哪一个。
     *
     * （8）适配器模式：
     * 封装对象，并提供不同的接口。
     *
     * （9）观察者模式：
     * 让对象能够在状态改变时被通知。
     *
     * （10）模板方法模式：
     * 由子类决定如何实现一个算法中的步骤。
     *
     * （11）组合模式：
     * 客户用一致的方式处理对象集合和单个对象。
     *
     * （12）单例模式：
     * 确保有且只有一个对象被创建。
     *
     * （13）抽象工厂模式：
     * 允许客户创建对象的家族，而无需指定它们的具体类。
     *
     * （14）命令模式：
     * 封装请求成为对象。
     */
    public static void main(String[] args) {

    }

}
