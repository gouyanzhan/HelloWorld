package com.siwuxie095.forme.designpattern.category.chapter2nd.example2nd;

/**
 * @author Jiajing Li
 * @date 2019-08-11 14:22:43
 */
public class Main {

    /**
     * 认识观察者模式：
     *
     * 先来看看报纸和杂志的订阅是怎么回事：
     * 1、报社的业务就是出版报纸；
     * 2、向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。
     * 只要你是他们的订户，你就会一直收到新报纸；
     * 3、当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来；
     * 4、只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或
     * 取消订阅报纸；
     *
     * 出版者 + 订阅者 = 观察者模式
     * 如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回
     * 事，只是名称不太一样：出版者改称为 "主题"（Subject），订阅
     * 者改称为 "观察者"（Observer）。
     * 即：
     * 主题对象管理某些数据。当主题内的数据改变就会通知观察者。观察
     * 者已经订阅（注册）主题以便在主题数据改变时能够收到更新。
     * 一旦数据改变，新的数据会以某种形式送到观察者手上。
     *
     * （出版-订阅 或 发布-订阅）
     *
     * 观察者模式：
     * 定义对象之间的一对多依赖，这样一来，当一个对象改变状态时，它
     * 的所有依赖者都会收到通知并自动更新。
     *
     * 主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题
     * 状态一有变化，观察者就会被通知。根据通知的风格，观察者可能因
     * 此新值而更新。
     *
     * 实现观察者模式的方法不止一种，但是以包含 Subject 与 Observer
     * 接口的类设计的做法最常见。
     *
     * 问：
     * 这和一对多的关系有何关联？
     * 答：
     * 利用观察者模式，主题是具有状态的对象，并且可以控制这些状态。
     * 也就是说，有 "一个" 具有状态的主题。另一方面，观察者使用这
     * 些状态，虽然这些状态并不属于他们。有许多的观察者，依赖主题
     * 来告诉他们状态何时改变了。这就产生了一个关系："一个" 主题对
     * "多个" 观察者的关系。
     *
     * 问：
     * 其间的依赖是如何产生的？
     * 答：
     * 因为主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化
     * 时更新，这样比起让许多对象控制同一份数据来，可以得到更干净的
     * OO 设计。
     *
     *
     *
     * 松耦合的威力
     *
     * 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。
     * 观察者提供了一种对象设计，让主题和观察者之间松耦合。
     *
     * 为什么呢？
     *
     * 关于观察者的一切，主题只知道观察者实现了某个接口（也就是 Observer
     * 接口）。主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。
     *
     * 任何时候都可以增加新的观察者。因为主题唯一依赖的东西是一个实现 Observer
     * 接口的对象列表，所以可以随时增加新的观察者。事实上，在运行时可以用
     * 新的观察者取代现有的观察者，主题不会受到任何影响。同样的，也可以在
     * 任何时候删除某些观察者。
     *
     * 有新类型的观察者出现时，主题的代码不需要修改。假如有个新的具体类需要
     * 当观察者，我们不需要为了兼容新类型而修改主题的代码，所有要做的就是在
     * 新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只
     * 会发送通知给所有实现了观察者接口的对象。
     *
     * 我们可以独立的复用主题和观察者。如果我们在其他地方需要使用主题或观察
     * 者，可以轻易的复用，因为二者并非紧耦合。
     *
     *
     *
     * 九个 OO 原则之第四个设计原则：
     * 为了交互对象之间的松耦合设计而努力。
     *
     * 松耦合的设计之所以能让我们建立又弹性的 OO 系统，能够应对变化，是因为
     * 对象之间的互相依赖降到了最低。
     */
    public static void main(String[] args) {

    }

}
