package com.siwuxie095.forme.designpattern.category.chapter4th.example9th;

/**
 * @author Jiajing Li
 * @date 2019-10-14 17:42:12
 */
public class Main {

    /**
     * 抽象工厂模式
     *
     * 提供了一个接口，用于创建相关或依赖对象的家族，而不需要指定
     * 具体类。
     *
     *
     * 抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需
     * 要知道（或关心）实际产出的具体产品是什么。这样一来，客户就
     * 从具体的产品中被解耦。
     *
     *
     * 抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这
     * 个接口包含了一组方法用来生产产品（整个产品家族）。
     * （PS：所有不同的产品共同构成了产品家族）
     *
     * 具体工厂用来实现不同的产品家族。要创建一个产品，客户只要使
     * 用其中的一个工厂，而完全不需要实例化任何产品对象。
     *
     * 客户代码中只需涉及抽象工厂，运行时将自动使用实际的工厂。
     *
     *
     * 不难发现，抽象工厂的每个方法实际上看起来都像是工厂方法。那
     * 么，工厂方法是不是潜伏在抽象工厂里面？是的，抽象工厂的方法
     * 经常以工厂方法的方式实现。因为抽象工厂的任务是定义一个负责
     * 创建一组产品的接口。这个接口内的每个方法都负责创建一个特定
     * 产品，同时利用实现抽象工厂的子类来提供这些具体的做法。所以，
     * 在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。
     *
     *
     * 工厂方法模式和抽象工厂模式的异同与好坏：
     * （1）工厂方法模式使用的类，抽象工厂模式使用的是对象。
     * （2）二者都是用来创建对象，工厂方法模式通过继承来实现，抽象
     * 工厂模式通过对象组合来实现。
     * 这意味着，利用工厂方法模式创建对象，需要扩展一个类，并覆盖它
     * 的工厂方法。而这个工厂方法正是用来创建对象的。其实整个工厂方
     * 法模式只不过就是通过子类来创建对象。用这种做法，客户只需要知
     * 道他们所使用的抽象类型即可，而由子类来负责决定具体类型。换句
     * 话说，只是负责将客户从具体类型中解耦。
     * 而抽象工厂模式则提供了一个用来创建一个产品家族的抽象类型。这
     * 个类型的子类定义了产品被产生的方法。要想使用这个工厂，必须先
     * 实例化它，然后将它传入一些针对抽象类型所写的代码中。所以，和
     * 工厂方法模式一样，也可以把客户从所使用的具体产品中解耦。
     * 抽象工厂模式的另一个优点则是：可以把一群相关的产品集合起来。
     * （3）当抽象工厂模式中加入新产品时，就必须改变接口，且要深入
     * 改变每个子类。这就有点严重了，毕竟是很繁重的工作。但却不得不
     * 这么做，因为抽象工厂模式正是用来创建整个产品家族的。
     * （4）抽象工厂模式经常使用工厂方法来实现具体工厂。
     * （5）工厂方法模式：创建一个产品；抽象工厂模式：创建产品家族。
     */
    public static void main(String[] args) {
        AbstractFactory factory = new ConcreteFactory1st();
        Client client = new Client(factory);
    }

}
