package com.siwuxie095.forme.designpattern.category.chapter4th.example7th;

/**
 * @author Jiajing Li
 * @date 2019-10-14 11:05:23
 */
public class Main {

    /**
     * 本例是一个很依赖的比萨店 DependentPizzaStore
     *
     * 不妨来看看对象依赖，当你直接实例化一个对象时，就是在依赖它的具体类。
     * 本例中，是由比萨店来创建所有的比萨对象，而不是委托给工厂，即 依赖性
     * 很高。
     *
     * 本例中的比萨店依赖于所有的比萨对象，因为它直接创建这些比萨对象。如果
     * 这些比萨类的实现改变了，那么可能必须修改比萨店。
     *
     * 因为对于比萨具体实现的任何改变都会影响到比萨店。所以说比萨店 "依赖于"
     * 比萨的实现。比如，每新增一个比萨种类，就等于让比萨店多了一个依赖。
     *
     * 很明显，代码里减少对具体类的依赖是件 "好事"。事实上，有一个OO设计原
     * 则就正式阐述了这一点。
     *
     *
     * 九个 OO 原则之第六个设计原则：
     * 要依赖抽象，不要依赖具体类。
     *
     * （也即 依赖倒置原则）
     *
     * 注意：这个原则和 "针对接口编程，不针对实现编程" 看起来很像，实则不然。
     *
     * 以 "Pizza pizza = new NewYorkStyleCheesePizza();" 为例说明：
     *
     * 前面 "Pizza pizza" 的声明正是 "针对接口编程，不针对实现编程" 的具现，而 "要依赖抽象，
     * 不要依赖具体类" 正是为了解决后面 "new NewYorkStyleCheesePizza()"。
     *
     * 这个原则更强调 "抽象"：不能让高层组件依赖低层组件，而且，不管是高层或
     * 低层组件，两者都应该依赖于抽象。
     *
     * 所谓高层组件，是由其他低层组件定义其行为的类。比如，比萨店是一个高层组
     * 件，因为它的行为是由比萨定义的。比萨店创建所有不同的比萨对象，准备、烘
     * 烤、切片、装盒，而比萨本身属于低层组件。
     *
     * 即 高层组件：调用者；低层组件：被调用者。
     *
     *
     * 根据这个原则，应该重写代码以便于依赖抽象类，而不依赖具体类。对于高层及
     * 低层模块都应该如此。
     *
     * 本例中，比萨店的主要问题在于：它依赖每个比萨类型。因为它在自己的 orderPizza()
     * 方法中实例化了比萨具体类型。
     *
     * 虽然已经创建了一个抽象，即 Pizza，但仍在代码中实际的创建了具体比萨，
     * 所以这个抽象没什么影响力。
     *
     * 而工厂方法模式正好能将这些实例化对象的代码从 orderPizza() 中独立
     * 出来。
     *
     * 此时，高层组件（即 比萨店）和低层组件（即 这些具体比萨）都依赖了 Pizza
     * 抽象。
     * （1）比萨店使用 Pizza 抽象的行为，所以依赖 Pizza 抽象。
     * （2）具体比萨继承 Pizza 抽象，被 Pizza 抽象所约束，所以依赖 Pizza 抽象。
     *
     *
     * 依赖倒置，即要采用自底向上的方式，逐步抽象。即 不从高层组件开始设计，
     * 而是先考虑低层组件，将低层组件进行抽象化，再开始设计高层组件。
     * 在本例中，就是不从比萨店开始设计（如果这样，就是自顶向下），而是先从
     * 具体比萨开始，抽象出一个Pizza 接口，即 这些具体比萨共享一个 Pizza
     * 接口。有了比萨抽象之后，就可以开始设计比萨店，不用理会具体比萨了。具
     * 体做法就是利用工厂来将这些具体比萨取出比萨店。
     * 这样一来，各种不同的具体比萨就只能依赖一个抽象，而比萨店也会依赖这个
     * 抽象。
     * （PS：这里的接口是广义的）
     *
     *
     * 为避免违反依赖倒置原则，有如下三个指导方针：
     * （1）变量不可以持有具体类的引用：
     * 如果使用 new，就会持有具体类的引用。可以改用工厂来避开这样的做法。
     * （2）不要让类派生自具体类：
     * 如果派生自具体类，就会依赖具体类。请派生自一个抽象（接口或抽象类）。
     * （3）不要覆盖基类中已实现的方法：
     * 如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽
     * 象。基类中已实现的方法，应该由所有的子类共享。
     *
     * 对于这三个指导方针，不求完全遵守，但应该尽量达到。正如其他许多的原
     * 则一样，应该尽量达到这个原则，而不是随时都要遵守这个原则。毕竟，任
     * 何 Java 程序都有违反这些指导方针的地方。
     * 如果能将这些方针内化成你思考的一部分，那么在设计时，就能知道何时有
     * 足够的理由违反这样的原则。
     * 比如，如果有一个不像是会改变的类，那么在代码中直接实例化具体类也就
     * 没什么大碍。就像平常在程序中不假思索地就实例化了字符串对象，显然是
     * 违反了这个原则的，但却又可以这么做。因为字符串不可能改变。
     */
    public static void main(String[] args) {

    }

}
