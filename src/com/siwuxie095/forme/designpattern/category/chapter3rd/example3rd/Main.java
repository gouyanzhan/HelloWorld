package com.siwuxie095.forme.designpattern.category.chapter3rd.example3rd;

/**
 * @author Jiajing Li
 * @date 2019-10-10 10:46:45
 */
public class Main {

    /**
     * 认识装饰者模式：
     * 显然，利用继承无法完全解决问题，在星巴兹遇到的问题有：
     * 类数量爆炸、设计死板，以及基类加入的新功能并不适用于所有的子类。
     *
     * 所以，这里要采用不一样的做法：以饮料为主体，然后在运行时以调料来
     * "装饰"（decorate）饮料。
     * 比如，顾客想要在深焙咖啡中加摩卡和奶泡，那么要做的是：
     * （1）拿一个深焙咖啡 DarkRoast 对象。
     * （2）以摩卡 Mocha 对象装饰它。
     * （3）以奶泡 Whip 对象装饰它。
     * （4）调用 cost() 方法，并依赖委托（delegate）将调料的价格加上去。
     *
     * 好了！但是如何 "装饰" 一个对象，而 "委托" 又要如何与此搭配使用呢？
     * 提示：把装饰者对象当成 "包装者"。
     *
     * 所以：
     * （1）装饰者和被装饰对象有相同的超类型。
     * （2）可以用一个或多个装饰者包装一个对象。
     * （3）既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过
     * 的对象代替它。
     * （4）装饰者可以在所委托被装饰者的行为之前与（或）之后加上自己的行为，以达到特定的目的。（关键点）
     * （5）对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
     *
     *
     * 装饰者模式：
     * 动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
     *
     *
     * 值得注意的是，组件和装饰者，既可以是抽象类，也可以是接口。这里使用了抽象类做例子。
     */
    public static void main(String[] args) {

    }

}
