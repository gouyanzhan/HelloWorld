package com.siwuxie095.forme.designpattern.category.chapter6th.example1st;

/**
 * @author Jiajing Li
 * @date 2019-10-27 17:25:55
 */
public class Main {

    /**
     * 封装调用
     *
     * 在谍战盛行的时期，绝密文件投递箱促成了间谍工业的革命。投递者只要把需求丢进去，就会有人消失，
     * 甚至是政府在一朝一夕之间改朝换代。而投递者不必管何时、何处、或者如何完成，反正就是完成了！
     *
     *
     * 在这里，会把封装带到一个全新的境界：把方法调用（method invocation）封装起来。
     *
     * 没错，通过封装方法调用，可以把运算块包装成形。所以调用此运算的对象不需要关心事情是如何进行
     * 的，只要知道如何使用包装成形的方法来完成它就可以。通过封装方法调用，也可以做一些很聪明的事
     * 情，例如记录日志，或者重复使用这些封装来实现撤销（undo）。
     *
     *
     * 现在，有一个新需求
     *
     * 设计一个家电自动化遥控器的 API。这个遥控器具有七个可编程的插槽（每个插槽都可以指定到一个
     * 不同的家电装置），每个插槽都有对应的一对开关按钮。这个遥控器还具备一个整体的撤销按钮（即
     * 一共 15 个按钮）。
     * 现在有一组 Java 类，这些类是由多家厂商开发出来的，用来控制家电的自动化装置，它们分别是：
     * 灯 Light、吊扇 CeilingFan、电视 TV、音响 Stereo、车库门 GarageDoor、洒水器 Sprinkler、
     * 热水浴缸 Hottub。
     * 希望能够设计一组控制遥控器的 API，让每个插槽都能够控制一个或一组装置。请注意，能够控制目前
     * 的装置和任何未来可能出现的装置，这一点是很重要的（即 扩展性/可插拔性，某一个插槽控制的家电
     * 装置是可以替换的）。
     *
     *
     * 看起来类好像不少，但接口各有差异。许多厂商类都具备 on() 和 off() 方法，除此之外，还有一些
     * 方法像是 setTemperature()、setVolume() 等等。麻烦还不只是这样，这些类以后还会越来越多。
     * 也就是说，以后还会有各式各样的方法。所以，设计一个遥控器 API 变的很有挑战性！
     *
     * 显然，将来会有更多的厂商类，而且每个类还会有各式各样的方法，这应该是分离的关键点。即 遥控器
     * 应该知道如何解读按钮被按下的动作，然后发出正确的请求，但是遥控器不需要知道这些家电自动化的
     * 细节。
     *
     * 即 如下伪代码是很糟糕的设计：
     * if slot1 == Light, then light.on(); else if slot1 == Stereo, then stereo.on();
     *
     * 因为只要有新的厂商类进来，就必须修改代码，这样会造成潜在的错误，而且工作没完没了。该怎么办？
     *
     * 此时，设计模式中的命令模式可以有所帮助。
     *
     * 命令模式可以将 "动作的请求者" 对象从 "动作的执行者" 对象中解耦出来。在本例中，请求者对象就
     * 是遥控器，执行者对象就是厂商类其中之一的实例，而解耦的方式便是通过 "命令对象"。利用命令对象，
     * 可以把请求（即 动作，例如打开灯）封装成一个特定对象。所以，如果对每个按钮都存储一个命令对象，
     * 那么当按钮被按下的时候，就可以请命令对象做相关的工作。遥控器并不知道工作内容是什么，只要有个
     * 命令对象能和正确的对象沟通，把事情做好就可以了。这样，遥控器就和厂商类解耦了。
     *
     * 听起来像是一个正确的方向，但仍然无法理解这个模式，具体该如何做呢？
     */
    public static void main(String[] args) {

    }

}
