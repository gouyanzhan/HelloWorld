package com.siwuxie095.forme.designpattern.category.chapter7th.example4th;

/**
 * @author Jiajing Li
 * @date 2019-11-04 18:08:32
 */
public class Main {

    /**
     * 为 JDK 写一个适配器
     *
     *
     * 旧世界的枚举器 Enumeration
     *
     * 在早期的集合类型（Vector、Stack、Hashtable）中都实现了一个名为
     * elements() 的方法，该方法会返回一个 Enumeration，它可以逐一走
     * 过此集合内的每个元素，而无需知道它们在集合内是如何被管理的。
     *
     * 新世界的迭代器 Iterator
     *
     * 当 Sun 推出更新后的集合类时，开始使用 Iterator 接口，这个接口和
     * Enumeration 接口很像，都可以让你遍历此集合内的每个元素，但不同的
     * 是，迭代器还提供了删除元素的能力。
     *
     *
     * 现在，经常面对遗留代码，这些代码暴露出 Enumeration 接口，但是又
     * 希望在新的代码中只使用迭代器。想解决这个问题，就要构造一个适配器，
     * 将枚举器适配到迭代器。
     *
     * 即
     * 客户：调用者
     * 目标：Iterator
     * 被适配者：Enumeration
     * 适配器：EnumerationIterator
     *
     * 首先需要找出这两个接口中方法的映射关系，即 要找出每一个适配器方法
     * 在被适配者中的对应方法是什么。
     *
     * EnumerationIterator 实现了目标接口 Iterator，而此目标接口是由
     * 被适配者所组合的。
     *
     * 由于 Enumeration 中没有 remove() 方法，而且 Enumeration 是
     * 一个只读接口，适配器无法实现一个有实际功能的 remove() 方法，所以
     * 直接抛一个运行时异常 UnsupportedOperationException 即可。
     *
     * 在本例中，可以看到，适配器并不完美，客户必须小心潜在的异常，但只
     * 要客户够小心，而且适配器的文档能做出说明，这也算是一个合理的解决
     * 方案。
     *
     * 虽然 Java 已经采用了迭代器，但还是有相当多的遗留 "客户代码"，依
     * 赖于枚举器接口，所以利用适配器将迭代器转换成枚举器，还是很有用的
     * 技巧。
     *
     * 而反过来，也可以将 Iterator 适配成 Enumeration。
     *
     *

     * 关于装饰者模式与适配器模式的差异：
     *
     * 装饰者的工作全都是和 "责任" 相关的。当事情一涉及到装饰者，就表示有
     * 一些新的行为或责任要加入到你的设计中。
     *
     * 当你必须将若干类整合在一起来提供你的客户所期望的接口时，适配器就发
     * 挥作用了。毕竟被解耦的客户才是快乐的客户。
     *
     * 装饰者就只是一个装饰者，却不知道还有多少其他的装饰者会再进行包装，
     * 当一个方法调用委托给装饰者时，根本无知道有多少其他的装饰者已经处理
     * 过这个调用。
     *
     * 而对于适配器，只要适配器工作顺利，客户不会意识到适配器的存在。适配
     * 器的好处在于，允许客户使用新的库和子集合，无须改变 "任何" 代码，由
     * 适配器做转换即可。
     *
     * 装饰者也可以让 "新行为" 加入类中，而无须修改现有代码。适配器就像
     * 是装饰者的变体一样，都是用来包装对象的。
     *
     * 适配器 "一定会" 进行接口的转换，但装饰者 "绝不会" 这么做。所以
     * 装饰者也像是适配器的变体一样，只是接口不会改变。
     *
     * 装饰者的工作是扩展所包装对象的行为或责任，并不像适配器那样去做传送。
     *
     * 总体而言，虽然二者看起来相似，但其意图/用途却差异颇大。
     */
    public static void main(String[] args) {

    }

}
