package com.siwuxie095.forme.designpattern.category.chapter7th.example2nd;

/**
 * @author Jiajing Li
 * @date 2019-11-04 16:54:27
 */
public class Main {

    /**
     * 适配器模式
     *
     * 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类
     * 可以合作无间。
     *
     *
     * 现在，知道了这个模式可以通过创建适配器进行接口转换，让不兼容的接口变成
     * 兼容。这可以让客户从实现的接口解耦。如果一段时间后，想要改变接口，适配
     * 器可以将改变的部分封装起来，客户就不必为了应对不同的接口而每次跟着修改。
     *
     * 此模式中：
     * （1）客户只看到目标接口。
     * （2）适配器实现目标接口。
     * （3）适配器与被适配者组合，所有的请求都委托给被适配者。
     *
     * 该模式也充满着良好的 OO 设计原则：使用对象组合，以修改的接口包装被适配
     * 者。这种做法还有额外的优点，即 被适配者的任何子类，都可以搭配着适配器使
     * 用。
     *
     * 需要注意的是，这个模式是如何把客户和接口绑定起来，而不是和实现绑定起来。
     * 可以使用数个适配器，每一个都负责转换不同组的后台类。或者，也可以加上新
     * 的实现，只要它们遵守目标接口就可以。
     *
     *
     *
     * 对象适配器
     *
     * 其实适配器一共分为两种："对象" 适配器和 "类" 适配器。
     *
     * 本例中的就是对象适配器，那么什么是类适配器呢？类适配器需要使用多继承来
     * 实现，即 适配器同时继承目标和被适配者。
     *
     * 二者唯一的区别在于：对象适配器是使用组合来适配被适配者，类适配器则是继
     * 承被适配者和目标。
     *
     * 注意：Java 中没有类的多继承，但是却有接口的多实现。
     */
    public static void main(String[] args) {

    }

}
