package com.siwuxie095.forme.designpattern.category.chapter7th.example8th;

/**
 * @author Jiajing Li
 * @date 2019-11-04 23:47:04
 */
public class Main {

    /**
     * 如何不要赢得太多的朋友和影响太多的对象
     *
     * 究竟要怎样才能避免这样呢？这个提供了一些方针：就任何对象而言，在该对象
     * 的方法内，只应该调用属于以下范围的方法：
     * （1）该对象本身
     * （2）被当作方法的参数而传递进来的对象
     * （3）此方法所创建或实例化的任何对象
     * （4）对象的任何组件
     *
     * 注：从（1）（2）（3）可知，如果某对象是调用其他的方法的返回结果，那么
     * 不要调用该对象的方法。而对于（4）来说，"组件" 可以想象成是被当前对象
     * 所引用的任何对象。换句话说，可以把这想象成是 "有一个"（HAS-A）的关系。
     *
     * 这听起来有点严厉，不是吗？如果调用从另一个调用中返回的对象 Y 的方法，
     * 会有什么害处呢？如果这样做，相当于向另一个对象 Y 的子部分发请求（而增
     * 加我们直接认识的对象数目）。在这种情况下，原则要我们改为：要求该对象 X
     * 为我们作出请求，这样一来，就不需要认识该对象 X 的组件 Y 了（让我们的
     * 朋友圈子维持在最小的状态）。
     *
     * 举例说明：
     * 现在有 House 家、WeatherStation 气象站、Thermometer 温度计
     *
     * 家要从气象站获取温度，气象站从温度计获取温度，返回给家
     *
     * 对于 House1st 来说，是符合该原则的。因为在气象站中加入了一个方法
     * getTemperature() 用来向温度计请求温度。这可以减少所依赖的类的数目。
     *
     * 对于 House2nd 来说，是不符合该原则的。因为它是先从气象站对象（X）
     * 取得了温度计对象（Y），然后再从温度计对象取得温度。
     *
     * 对于 House3rd 来说，是不符合该原则的。同 House2nd，在此调用的方法
     * getTemperature() 属于另一次调用 station.getThermometer() 的返
     * 回对象。
     *
     * 对于 House4th 来说，是符合该原则的。但是，把程序改成这样真的有意义
     * 吗？
     */
    public static void main(String[] args) {

    }

}
