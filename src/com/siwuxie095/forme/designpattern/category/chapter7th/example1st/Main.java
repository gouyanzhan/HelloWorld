package com.siwuxie095.forme.designpattern.category.chapter7th.example1st;

/**
 * @author Jiajing Li
 * @date 2019-11-04 15:33:53
 */
public class Main {

    /**
     * 随遇而安的适配器模式和外观模式：让一件事情看起来更像是另一回事
     *
     * 在这里，要进行一项任务，其不可能的程度，简直就像是将一个方块放
     * 进一个圆洞中。听起来不可能？有了设计模式，就有可能。
     *
     * 对于之前的装饰者模式而言，是将对象包装起来，赋予它们新的职责。
     * 而现在则是以不同目的，包装某些对象：让它们的接口看起来不像是自
     * 己而像是别的东西。即 让包装这些对象的接口看起来不像是对象自己
     * 而像是别的东西。为何要这样做？因为这样就可以在设计中，将类的接
     * 口转换成想要的的接口，以便实现不同的接口，即 适配器模式。不仅
     * 如此：还要探讨另一个模式，将对象包装起来以简化其接口，即 外观
     * 模式。
     *
     *
     * 先说适配器模式
     *
     * 真实世界的适配器，比如：如果你需要在欧洲国家使用美国制造的笔记
     * 本，就需要一个交流电的适配器。它位于美式插头和欧式插座的中间，
     * 它的工作是将欧式插座转换成美式插座，好让美式插座可以插进这个插
     * 座得到电力。或者可以这么认为，适配器改变了插座的接口，以符合美
     * 式笔记本的需求。
     *
     * 客户：美式笔记本（美式插头）
     * 目标：美式插座
     * 被适配者：欧式插座
     * 适配器：插座适配器
     *
     * 即 美式插头需要一个美式插座，但现在只有欧式插座，故需要进行适配。
     *
     *
     * 面向对象的适配器也是一样，将一个接口转换成另一个接口，以符合客
     * 户的期望。
     *
     * 假设已有一个软件系统，你希望它能和一个新的厂商类库搭配使用，但
     * 是这个新厂商所设计出来的接口，不同于旧厂商的接口。即 接口无法
     * 匹配，所以无法工作。你不想改变现有的代码（现有系统、旧厂商接口、
     * 新厂商接口），解决这个问题，该怎么做？
     *
     * 此时，就可以写一个类（适配器），将新厂商接口转换成你所期望的类。
     * 这个适配器工作起来就如同一个中间人一样，它将客户所发出的请求转
     * 换成厂商类能理解的请求。即 客户发出请求，现有系统通过适配器将
     * 请求转换成厂商类能理解的请求。
     *
     * 客户：现有系统
     * 目标：旧厂商接口
     * 被适配者：新厂商接口
     * 适配器：适配器
     *
     * 即 现有系统的请求需要通过旧厂商接口的方式传递给新厂商接口，故
     * 需要进行适配。
     *
     *
     * 再如，现在有鸭子接口 Duck 和火鸡接口 Turkey，但是现在鸭子
     * 测试驱动 DuckTestDrive 缺鸭子对象，想用一些火鸡对象来冒充。
     * 因为火鸡接口的不同，所以不能公然拿来用。就需要写一个火鸡适配
     * 器 TurkeyAdapter。
     *
     * 客户：DuckTestDrive
     * 目标：Duck
     * 被适配者：Turkey
     * 适配器：TurkeyAdapter
     *
     *
     * 其中：
     * （1）客户是依据目标接口实现的。
     * （2）适配器实现了目标接口，并持有被适配者的实例。
     * （3）客户通过将请求发给适配器，即 request()，适配器将请求发给
     * 被适配者，即 translatedRequest()。
     *
     *
     * 客户使用适配器的过程如下：
     * （1）客户通过目标接口调用适配器的方法对适配器发出请求。
     * （2）适配器使用被适配者接口把请求转换成被适配者的一个或多个调用
     * 接口。
     * （3）客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。
     *
     *
     * 疑问与解答：
     *
     * 问：
     * 一个适配器需要做多少 "适配" 的工作？如果需要实现一个很大的目标
     * 接口，似乎有 "很多" 工作要做。
     * 答：
     * 的确如此。实现一个适配器所需要进行的工作，的确和目标接口的大小
     * 成正比。如果不用适配器，就必须改写客户端的代码来调用这个新的接
     * 口，将会花许多力气来做大量的调查工作和代码改写工作。相比之下，
     * 提供一个适配器类，将所有的改变封装在一个类中，是比较好的做法。
     *
     * 问：
     * 一个适配器只能够封装一个类吗？
     * 答：
     * 适配器模式的工作是将一个接口转换成另一个。虽然大多数的适配器模
     * 式所采取的例子都是让一个适配器包装一个被适配者，但是我们知道这
     * 个世界其实复杂多了，所以你可能遇到一些状况，需要让一个适配器包
     * 装多个被适配者。这涉及另一个模式，即 外观模式。
     *
     * 问：
     * 万一系统中新旧并存，旧的部分期望旧的厂商接口，但是却已经使用新
     * 厂商的接口编写了这一部分，这个时候应该怎么办？这里使用适配器，
     * 那里却使用未包装的接口，这实在是让人感到混乱。如果只是固守旧的
     * 代码，完全不要管适配器，这样子会不会好一些？
     * 答：
     * 不需要如此。可以创建一个双向的适配器，支持两边的接口。想创建一
     * 个双向的适配器，就必须实现所涉及的两个接口，这样，这个适配器可
     * 以当作旧的接口，或者当作新的接口使用。
     */
    public static void main(String[] args) {
        Duck duck = new MallardDuck();
        DuckTestDrive.testDuck(duck);

        System.out.println();

        Turkey turkey = new WildTurkey();
        TurkeyAdapter turkeyAdapter = new TurkeyAdapter(turkey);
        DuckTestDrive.testDuck(turkeyAdapter);
    }



}
