package com.siwuxie095.forme.designpattern.category.chapter9th.example5th;

/**
 * @author Jiajing Li
 * @date 2019-11-06 16:48:00
 */
public class Main {

    /**
     * 迭代器模式
     *
     * 提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露
     * 其内部的表示。
     *
     *
     * 迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部
     * 的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚
     * 合的接口和实现，也让责任各得其所。
     *
     * 这很有意义：这个模式给你提供了一种方法，可以顺序访问一个聚合
     * 对象中的元素，而又不用知道内部是如何表示的。在之前的例子中可
     * 以看到这一点，在设计中使用迭代器的影响是明显的：如果你有一个
     * 统一的方法访问聚合中的每一个对象，你就可以编写多态的代码和这
     * 些聚合搭配使用。
     *
     * 另一个对设计造成重要影响的，是迭代器模式把在元素之间游走的责
     * 任交给迭代器，而不是聚合对象。这不仅让聚合的接口和实现变得更
     * 简洁，也可以让聚合更专注在它应该专注的事情上面（即 管理对象
     * 集合），而不必去理会遍历的事情。
     *
     *
     * 疑问与解答
     *
     * 问：
     * 我看到其他书上让迭代器类提供一些方法叫做 first()、next()、
     * isDone() 和 currentItem()。为什么这些方法不一样？
     * 答：
     * 这些是 "经典" 的方法名称，它们随着时间的流逝渐渐改变了，而
     * 现在在 Java 自带的 Iterator 中所使用的名称有 next()、
     * hasNext() 甚至 remove()。
     * 不妨看看这些经典的方法。next() 和 currentItem() 实际上
     * 被合并成了 Iterator 中的 next()。isDone() 变成了 Iterator
     * 中的 hasNext()。至于 first() 则不存在对应，这是在 Java
     * 中，更倾向于取得一个新的迭代器，而不是让目前的迭代器跳到一
     * 开始的位置。所以，其实这些接口没什么太大的差异。事实上，你
     * 可以在自己的迭代器内部加上许多的方法，例如 remove()。
     *
     * 问：
     * 我听说 "内部的" 迭代器和 "外部的" 迭代器。这是什么？在前面
     * 的例子中实现的是哪一种？
     * 答：
     * 实现的是外部的迭代器，也就是说，客户通过调用 next() 取得下
     * 一个元素。而内部的迭代器则是由迭代器自己控制。在这种情况下，
     * 因为是由迭代器自行在元素之间游走，所以你必须告诉迭代器在游
     * 走的过程中，要做什么事情，也就是说，你必须将操作传给迭代器。
     * 因为客户无法控制遍历的过程，所以内部迭代器比外部迭代器更没
     * 有弹性。然而，某些人可能认为内部的迭代器比较容易使用，因为
     * 只需将操作告诉它，它就会帮你做完所有事情。
     *
     * 问：
     * 迭代器可以被实现成向后（向左）移动吗，就像向前（向右）移动
     * 一样？
     * 答：
     * 绝对可以。在这样的情况下，你可能要加上两个方法，一个方法取
     * 得前一个元素，而另一个方法告诉你是否已经到了集合的最前端。
     * Java 的 Collection Framework 提供了另一种迭代器接口，
     * 称为 ListIterator。这个迭代器在标准的迭代器接口上多加了
     * 一个 hasPrevious() 和 previous() 以及一些其他的方法。
     * 任何实现了 List 接口的集合，都支持这样的做法。
     *
     * 问：
     * 对于散列表这样的集合，元素之间并没有明显的次序关系，该怎么办？
     * 答：
     * 迭代器意味着没有次序。只是取出所有的元素，并不表示取出元素的
     * 先后就代表元素的大小次序。对于迭代器来说，数据结构可以是有次
     * 序的，或是没有次序的，甚至数据可以是重复的。除非某个集合的文
     * 件有特别说明，否则不可以对迭代器所取出的元素大小顺序作出假设。
     *
     * 问：
     * 你说可以用迭代器写出 "多态的代码"，可以再多做一些解释吗？
     * 答：
     * 当写了一个需要以迭代器当作参数的方法时，其实就是在使用多态的
     * 迭代器。也就是说，所写出的代码，可以在不同的集合中游走，只要
     * 这个集合支持迭代器即可。我们不在乎这个集合是如何被实现的，但
     * 依然可以编程在它内部的元素之间游走。
     *
     * 问：
     * 如果我使用 Java，不见得总是要利用 Java 自带的迭代器，可能
     * 想要使用自己的迭代器实现，和这些已经使用 Java 自带的迭代器
     * 的类进行整合，这做得到吗？
     * 答：
     * 或许可以吧。如果你有一个通用的迭代器接口，那么让你自己的集合
     * 和 Java 的集合（如：List、Vector）混合使用就会比较容易。
     * 但是请记住，如果你需要在自己的迭代器接口为你的集合新增功能，
     * 你可以随时扩展迭代器接口。
     *
     * 问：
     * 我看到 Java 有一个 Enumeration （枚举器）接口，它实现了
     * 迭代器模式吗？
     * 答：
     * Enumeration 其实是一个有次序的迭代器实现，它有两个方法，
     * hasMoreElements() 类似 hasNext()，而 nextElement()
     * 类似 next()。然而你应该比较想使用迭代器，而不是枚举器，
     * 因为大多数的 Java 类支持的都是迭代器。如果你想把二者互相
     * 转换，可以通过适配器模式来进行。
     *
     *
     *
     * 九个 OO 原则之第九个设计原则：
     * 一个类应该只有一个引起变化的原因
     *
     * 也称 单一职责（责任）原则
     *
     *
     * 如果允许这里的聚合实现它们内部的集合，以及相关的操作和遍历的方法，
     * 又会如何？已经知道，这会增加聚合中的方法个数，但又怎样？为什么这
     * 么做不好？
     * 这是因为，当允许一个类不但要完成自己的事情（管理相关操作），还同
     * 时要担负更多的责任（遍历）时，就给了这个类两个变化的原因。
     * 即 如果这个集合改变改变的话，这个类也必须改变。如果遍历的方式改变
     * 的话，这个类也必须跟着改变。
     * 所以，老朋友 "改变" 又成了设计原则的中心。
     *
     * 显然，应该要避免类内的改变，因为修改代码很容易造成许多潜在的错误。
     * 如果有一个类具有两个改变的原因，那么这会使得将来该类的变化机率上
     * 升，而当它真的改变时，你的设计中同时有两个方面将会受到影响。
     * 要如何解决呢？这个原则告诉我们将一个责任只指派给一个类。但这听起
     * 来容易，但做起来却并不简单：区分设计中的责任，是最困难的事情之一。
     * 因为大脑很习惯看着一大群行为，然后将它们集中在一起，尽管它们可能
     * 属于两个或多个不同的责任。想要成功的方法，就是努力不懈地检查你的
     * 设计，随着系统的成长，随时观察有没有迹象显示某个类改变的原因超过
     * 一个。
     *
     * 类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变
     * 的区域。所以，尽量让每个类保持单一责任。
     *
     *
     * 内聚（cohesion）
     *
     * 内聚用来度量一个类或模块紧密地达到单一目的或责任。
     *
     * 当一个类或模块被设计成只支持一组相关的功能时，就说它具有高内聚；
     * 反之，当被设计成支持一组不相关的功能时，就说它具有低内聚。
     *
     * 内聚是一个比单一责任原则更普遍的概念，但两者其实关系是很密切的。
     * 遵守这个原则的类容易具有很高的凝聚力，而且比背负许多责任的低内聚
     * 类更容易维护。
     */
    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        Client client = new Client(aggregate);
        client.doSomething();
    }

}
