package com.siwuxie095.forme.test.test012;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author Jiajing Li
 * @date 2019-04-19 16:04:47
 */
public class Main {

    /**
     * 说明的问题：正则表达式，参考链接：https://mp.weixin.qq.com/s/ejtbumkNZpaPSc4AP2XsoA
     *
     * 二、进阶篇
     *
     * 1、零宽断言
     * 断言：俗话的断言就是 “我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面 或 后面会出现满足指定规则的内容，
     * 意思是正则也可以像人类那样断定什么什么，比如"ss1aa2bb3"，正则可以用断言找出 aa2 前面有 ss1，也可以找出 aa2 后面有 bb3。
     * 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
     *
     * 断言分为四种：
     * （1）正向先行断言（正前瞻）：
     * 语法：(?=pattern)
     * 作用：匹配 pattern 表达式的前面内容，不返回本身。
     *
     * （2）正向后行断言（正后顾）：
     * 语法：(?<=pattern)
     * 作用：匹配 pattern 表达式的后面的内容，不返回本身。
     *
     * （3）负向先行断言（负前瞻）：
     * 语法：(?!pattern)
     * 作用：匹配非 pattern 表达式的前面内容，不返回本身。
     *
     * （4）负向后行断言（负后顾）：
     * 语法：(?<!pattern)
     * 作用：匹配非 pattern 表达式的后面内容，不返回本身。
     *
     *
     * 2、捕获和非捕获
     * 单纯说到捕获，意思是匹配表达式，但捕获通常和分组联系在一起，也就是 “捕获组”。
     * 捕获组：匹配子表达式的内容，把匹配结果保存到内存中的数字编号或显示命名的组里，
     * 以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
     *
     * 而根据命名方式的不同，捕获组又可以分为两种组：
     * （1）数字编号捕获组：
     * 语法：(exp)
     * 解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，
     * 在分组中，第 0 组为整个表达式，第一组开始为分组。
     *
     * （2）命名编号捕获组：
     * 语法：(?<name>exp)
     * 解释：分组的命名由表达式中的name指定
     *
     * 非捕获组：
     * 语法：(?:exp)
     * 解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
     *
     *
     * 3、反向引用
     *
     * 捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式
     * 内部进行引用，这种引用方式就是反向引用。
     *
     * 根据捕获组的命名规则，反向引用可分为：
     * （1）数字编号组反向引用：\k 或 \number
     * （2）命名编号组反向引用：\k 或 \'name'
     *
     * PS：捕获组通常是和反向引用一起使用的
     *
     * 捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。
     *
     * 这里所说的 “内容”，是匹配结果，而不是子表达式本身。而 “使用” 主要是用来查找一些重复的内容或者做替换指定字符。
     *
     *
     * 4、贪婪和非贪婪
     * （1）贪婪
     * 贪婪就是不满足，尽可能多的要。
     * 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，
     * 这匹配方式叫做贪婪匹配。
     * 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也
     * 叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
     *
     * PS：其实重复限定符就是贪婪量词
     *
     * 一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？
     * 是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，
     * 也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。
     *
     * （2）懒惰（非贪婪）
     * 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，
     * 这匹配方式叫做懒惰匹配。
     * 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，
     * 依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。
     *
     * 懒惰量词是在贪婪量词后面加个问好 ?
     * *?       重复任意次，但尽可能少重复
     * +?       重复 1 次或更多次，但尽可能少重复
     * ??       重复 0 次或 1 次，但尽可能少重复
     * {n,m}?   重复 n 到 m 次，但尽可能少重复
     * {n,}?    重复 n 次以上，但尽可能少重复
     *
     *
     * 5、反义
     * 元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符
     *
     * \W       匹配任意不是字母，数字，下划线，汉字的字符
     * \S       匹配任意不是空白符的字符
     * \D       匹配任意非数字的字符
     * \B       匹配不是单词开头或结束的位置
     * [^x]     匹配除了x以外的任意字符
     * [^aeiou] 匹配除了 aeiou 这几个字母以外的任意字符
     */
    public static void main(String[] args) {
        //first();
        //second();
        //third();
        fourth();
        fifth();
    }

    /**
     * 1、零宽断言
     * 断言：俗话的断言就是 “我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面 或 后面会出现满足指定规则的内容，
     * 意思是正则也可以像人类那样断定什么什么，比如"ss1aa2bb3"，正则可以用断言找出 aa2 前面有 ss1，也可以找出 aa2 后面有 bb3。
     * 零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
     *
     * 断言分为四种：
     * （1）正向先行断言（正前瞻）：
     * 语法：(?=pattern)
     * 作用：匹配 pattern 表达式的前面内容，不返回本身。
     *
     * （2）正向后行断言（正后顾）：
     * 语法：(?<=pattern)
     * 作用：匹配 pattern 表达式的后面的内容，不返回本身。
     *
     * （3）负向先行断言（负前瞻）：
     * 语法：(?!pattern)
     * 作用：匹配非 pattern 表达式的前面内容，不返回本身。
     *
     * （4）负向后行断言（负后顾）：
     * 语法：(?<!pattern)
     * 作用：匹配非 pattern 表达式的后面内容，不返回本身。
     */
    private static void first() {
        /*
         * 假设要用爬虫抓取 CSDN 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构：
         * "<span class="read-count">阅读数：641</span>"
         * 其中也就 ‘641’ 这个是变量，也就是说不同文章有不同的值，当拿到这个字符串时，需要获得这里边的
         * ‘641’ 有很多种办法，但如果正则应该怎么匹配呢？
         */

        /*
         * 1、正前瞻
         *
         * "(?=</span>)" 可以匹配到前面的内容：
         * 如果是匹配前面的所有内容，则是 ".+(?=</span>)"；
         * 如果是匹配前面的数字，则是 "\\d+(?=</span>)"；
         */
        String test = "<span class=\"read-count\">阅读数：641</span>";
        String regex = ".+(?=</span>)";
        ifFindOfFirst(test, regex);
        regex = "\\d+(?=</span>)";
        ifFindOfFirst(test, regex);

        /*
         * 2、正后顾
         *
         * "(?<=<span class=\"read-count\">阅读数：)" 可以匹配到后面的内容：
         * 如果是匹配后面的所有内容，则是 "(?<=<span class=\"read-count\">阅读数：).+"。
         * 如果是匹配后面的数字，则是 "(?<=<span class=\"read-count\">阅读数：)\\d+"。
         */
        regex = "(?<=<span class=\"read-count\">阅读数：).+";
        ifFindOfFirst(test, regex);
        regex = "(?<=<span class=\"read-count\">阅读数：)\\d+";
        ifFindOfFirst(test, regex);

        /*
         * 3、负前瞻
         * 其实 负 就是 非 的意思
         *
         * 比如有一句 “我爱祖国，我是祖国的花朵”。
         *
         * 现在要找到 不是 '的花朵' 前面的 '祖国'。
         */
        test = "我爱祖国，我是祖国的花朵";
        regex = "祖国(?!的花朵)";
        ifFindOfFirst(test, regex);

        /*
         * 4、负后顾
         *
         * 现在要找到 不是 '我爱' 后面的 '祖国'。
         */
        regex = "(?<!我爱)祖国";
        ifFindOfFirst(test, regex);

    }

    private static void ifFindOfFirst(String test, String regex) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(test);
        if (matcher.find()) {
            System.out.println("匹配结果：");
            System.out.println(matcher.group());
        }
    }

    /**
     * 2、捕获和非捕获
     * 单纯说到捕获，意思是匹配表达式，但捕获通常和分组联系在一起，也就是 “捕获组”。
     * 捕获组：匹配子表达式的内容，把匹配结果保存到内存中的数字编号或显示命名的组里，
     * 以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
     *
     * 而根据命名方式的不同，捕获组又可以分为两种组：
     * （1）数字编号捕获组：
     * 语法：(exp)
     * 解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，
     * 在分组中，第 0 组为整个表达式，第一组开始为分组。
     *
     * （2）命名编号捕获组：
     * 语法：(?<name>exp)
     * 解释：分组的命名由表达式中的 name 指定
     *
     * 非捕获组：
     * 语法：(?:exp)
     * 解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
     */
    private static void second() {
        /*
         * 1、捕获组之数字编号捕获组
         *
         * 比如固定电话的：020-85653333
         * 它的正则表达式为：(0\d{2})-(\d{8})
         *
         * 可见，分组个数是 2，但是因为第 0 个为整个表达式本身，因此也一起输出了。
         */
        String test = "020-85653333";
        String regex = "(0\\d{2})-(\\d{8})";
        ifFindOfSecond1(test, regex);
        System.out.println();

        /*
         * 2、捕获组之命名编号捕获组
         *
         * 比如区号和号码也可以这样写:(?<quhao>0\d{2})-(?<haoma>\d{8})
         */
        regex = "(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
        ifFindOfSecond2(test, regex);

        /*
         * 3、非捕获组
         *
         * 假设不想要第一个分组，则可以这样写：(?:0\d{2})-(\d{8})
         */
        regex = "(?:0\\d{2})-(\\d{8})";
        ifFindOfSecond1(test, regex);
    }

    private static void ifFindOfSecond1(String test, String regex) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(test);
        if (matcher.find()) {
            System.out.println("分组的个数有：" + matcher.groupCount());
            for (int i = 0; i <= matcher.groupCount(); ++i) {
                System.out.println("第 " + i + " 个分组为：" + matcher.group(i));
            }
        }
    }

    private static void ifFindOfSecond2(String test, String regex) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(test);
        if (matcher.find()) {
            System.out.println("分组的个数有：" + matcher.groupCount());
            System.out.println(matcher.group("quhao"));
            System.out.println(matcher.group("haoma"));
        }
    }

    /**
     * 3、反向引用
     *
     * 捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式
     * 内部进行引用，这种引用方式就是反向引用。
     *
     * 根据捕获组的命名规则，反向引用可分为：
     * （1）数字编号组反向引用：\k 或 \number
     * （2）命名编号组反向引用：\k 或 \'name'
     *
     * PS：捕获组通常是和反向引用一起使用的
     *
     * 捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。
     *
     * 这里所说的 “内容”，是匹配结果，而不是子表达式本身。而 “使用” 主要是用来查找一些重复的内容或者做替换指定字符。
     */
    private static void third() {
        /*
         * 比如要查找一串字母 "aabbbbgbddesddfiid" 里成对的字母
         *
         * 按照之前学的正则，什么区间、限定、断言可能是办不到的，先用程序思维理一下思路：
         * 1）匹配到一个字母
         * 2）匹配第下一个字母，检查是否和上一个字母是否一样
         * 3）如果一样，则匹配成功，否则失败
         *
         * 这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？
         * 这下子捕获就有用处啦，可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。好了，有思路就要实践：
         * 首先匹配一个字母：\w
         * 需要做成分组才能捕获，因此写成这样：(\w)
         * 那这个表达式就有一个捕获组：(\w)
         * 然后要用这个捕获组作为条件，那就可以：(\w)\1
         * 这样就大功告成了
         *
         * 那么 \1 是什么意思呢？捕获组有两种命名方式，一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名
         * 在默认情况下都是以数字来命名，而且数字命名的顺序是从 1 开始的
         *
         * 因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 \k<1> 或者 \1
         * 当然，通常都是是后者
         */
        String test = "aabbbbgbddesddfiid";
        String regex = "(\\w)\\1";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(test);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }

        /*
         * 在举个替换的例子，假如想要把字符串中 abc 换成 a
         */
        test = "abcbbabcbcgbddesddfiid";
        regex = "(a)(b)c";
        System.out.println(test.replaceAll(regex, "$1"));;
    }

    /**
     * 4、贪婪和非贪婪
     * （1）贪婪
     * 贪婪就是不满足，尽可能多的要。
     * 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，
     * 这匹配方式叫做贪婪匹配。
     * 特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也
     * 叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
     *
     * PS：其实重复限定符就是贪婪量词
     *
     * 一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？
     * 是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，
     * 也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。
     *
     * （2）懒惰（非贪婪）
     * 懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，
     * 这匹配方式叫做懒惰匹配。
     * 特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，
     * 依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。
     *
     * 懒惰量词是在贪婪量词后面加个问好 ?
     * *?       重复任意次，但尽可能少重复
     * +?       重复 1 次或更多次，但尽可能少重复
     * ??       重复 0 次或 1 次，但尽可能少重复
     * {n,m}?   重复 n 到 m 次，但尽可能少重复
     * {n,}?    重复 n 次以上，但尽可能少重复
     */
    private static void fourth() {
        /*
         * 其实重复限定符就是贪婪量词，比如表达式：\d{3,6}
         * 用来匹配 3 到 6 位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有 6 个数字可以匹配，
         * 那它就是全部匹配到
         *
         * 由结果可见：本来字符串中的 “61762828” 这一段，其实只需要出现3个（617）就已经匹配成功了的，但是它并不
         * 满足，而是匹配到了最大能匹配的字符，也就是 6 个。
         */
        String test = "61762828 176 2991 44 871";
        String regex = "\\d{3,6}";
        System.out.println("文本：" + test);
        System.out.println("贪婪模式：" + regex);
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(test);
        while (matcher.find()) {
            System.out.println("匹配结果：" + matcher.group(0));
        }
        System.out.println();

        /*
         * 多个贪婪量词时，按照深度优先原则
         *
         * "617628" 是前面的 \d{1,2} 匹配出了 61，后面的 d{3,4} 匹配出了 7628
         * "2991" 是前面的 \d{1,2} 匹配出了 29 ，后面的 \d{3,4} 匹配出了 91
         * "87321" 是前面的 \d{1,2} 匹配出了 87，后面的 \d{3,4} 匹配出了 321
         */
        test = "61762828 176 2991 87321";
        regex = "(\\d{1,2})(\\d{3,4})";
        System.out.println("文本：" + test);
        System.out.println("贪婪模式：" + regex);
        pattern = Pattern.compile(regex);
        matcher = pattern.matcher(test);
        while (matcher.find()) {
            System.out.println("匹配结果：" + matcher.group(0));
        }

        /*
         * 非贪婪模式（懒惰）
         *
         * "61762" 是左边的懒惰匹配出 6，右边的贪婪匹配出 1762
         * "2991"  是左边的懒惰匹配出 2，右边的贪婪匹配出 991
         * "87321" 左边的懒惰匹配出 8，右边的贪婪匹配出 7321
         */
        test = "61762828 176 2991 87321";
        regex = "(\\d{1,2}?)(\\d{3,4})";
        System.out.println("文本：" + test);
        System.out.println("非贪婪模式：" + regex);
        pattern = Pattern.compile(regex);
        matcher = pattern.matcher(test);
        while (matcher.find()) {
            System.out.println("匹配结果：" + matcher.group(0));
        }

    }

    /**
     * 5、反义
     * 元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符
     *
     * \W       匹配任意不是字母，数字，下划线，汉字的字符
     * \S       匹配任意不是空白符的字符
     * \D       匹配任意非数字的字符
     * \B       匹配不是单词开头或结束的位置
     * [^x]     匹配除了x以外的任意字符
     * [^aeiou] 匹配除了 aeiou 这几个字母以外的任意字符
     */
    private static void fifth() {

    }


}
